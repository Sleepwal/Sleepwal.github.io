<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2023 CSP-J1真题</title>
      <link href="/2023/09/23/2023%E5%B9%B4CSP%E5%85%A5-J1%E7%9C%9F%E9%A2%98/"/>
      <url>/2023/09/23/2023%E5%B9%B4CSP%E5%85%A5-J1%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>In Process</p></blockquote><h1 id="一、-单项选择题"><a href="#一、-单项选择题" class="headerlink" title="一、  单项选择题"></a>一、  单项选择题</h1><ol><li> 在C++中，下面哪个关键字用于声明一个变量，其值不能被修改？（ ）。</li></ol><p>A.  unsigned </p><p>B.  const </p><p>C.  static </p><p>D.  mutable</p><blockquote><p>答案: B。在C++中，关键字<code>const</code>用于声明一个变量，表示其值是常量，不能被修改。一旦用<code>const</code>声明一个变量后，它的值在声明之后就不能再被修改，任何试图修改该变量的操作都会被编译器报错。<br>其中 A 选项为无符号性 B 为定义常亮 (不可修改)C 为静态变量 D 为可修改变量和 const</p></blockquote><ol start="2"><li> 八进制数12345670(8) 和07654321(8)的和为（ ）。</li></ol><p>A.  22222221(8)</p><p>B.  21111111(8)</p><p>C.  22111111(8)</p><p>D.  22222211(8)</p><blockquote><p>答案: D</p><p>直接算。笨方法是首先将八进制数转换为十进制数，然后将两个十进制数相加，最后将结果转换回八进制数。</p></blockquote><ol start="3"><li> 阅读下述代码，请问修改data的value成员以存储3.14，正确的方式是（ ）。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span>&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    <span class="type">float</span> value;</span><br><span class="line">    <span class="type">char</span> symbol;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">union</span> <span class="title class_">Data</span> data;</span><br></pre></td></tr></table></figure><p>A. data.value &#x3D; 3.14;</p><p>B. value.data &#x3D; 3.14;</p><p>C. data-&gt;value &#x3D; 3.14;</p><p>D. value-&gt;data &#x3D; 3.14;</p><blockquote><p> 答案: A。Union 为联合体，和 struct 类似，赋值应用<code>.</code>运算符，指针才能用<code>-&gt;</code>运算符</p></blockquote><ol start="4"><li> 假设有一个链表的节点定义如下：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;     </span><br><span class="line">    <span class="type">int</span> data;     </span><br><span class="line">    Node* next;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在有一个指向链表头部的指针：Node* head。如果想要在链表中插入一个新节点，其成员data的值为42，并使新节点成为链表的第一个节点，下面哪个操作是正确的？（ ）</p><p>A.  Node* newNode &#x3D; new Node; newNode-&gt;data &#x3D; 42; newNode-&gt;next &#x3D; head; head &#x3D; newNode;</p><p>B.  Node* newNode &#x3D; new Node; head-&gt;data &#x3D; 42; newNode-&gt;next &#x3D; head; head &#x3D; newNode;</p><p>C.  Node* newNode &#x3D; new Node; newNode-&gt;data &#x3D; 42; head-&gt;next &#x3D; newNode;</p><p>D.  Node* newNode &#x3D; new Node; newNode-&gt;data &#x3D; 42; newNode-&gt;next &#x3D; head;</p><blockquote><p> 答案: A</p><p>B 选项对 head 的 data 进行修改。</p><p>C、D 选项没有更新 head 的值，导致没法插入新的数据。</p></blockquote><ol start="5"><li> 根节点的高度为1，一根拥有2023个节点的三叉树高度至少为（ ）。</li></ol><p>A.  6</p><p>B.  7</p><p>C.  8</p><p>D.  9</p><blockquote><p> 答案: C</p><p>满三叉树的节点数为$s&#x3D;(3^n-1) \div 2$，2023 个节点介于 7 层到 8 层之间，所以最少需要 8 层二叉树，所以至少八层。</p></blockquote><p>6.  小明在某一天中依次有七个空闲时间段，他想要选出至少一个空闲时间段来练习唱歌，但他希望任意两个练习的时间段之间都有至少两个空闲的时间段让他休息，则小明一共有（ ）种选择时间段的方案。</p><p>A.  31</p><p>B.  18</p><p>C.  21</p><p>D.  33</p><blockquote><p> 答案: B。7个空闲时间1、2、3、4、5、6、7。</p><p> 只选一个练习时间段：随便一个都行，有 <strong>7</strong> 种。</p><p> 选 2 个练习时间段：</p><ol><li>选1，能选4、5、6、7，有4种</li><li>选2，能选5、6、7，有3种（往前选1，会重复）</li><li>选3，能选6、7，有2种</li><li>选4，能选7，有1种</li></ol><ul><li>共有 <strong>10</strong> 种。</li></ul><p> 选 3 个联系时间段：只能选1、4、7，有 <strong>1</strong> 种。</p><p> 。故总数为 18 种</p></blockquote><ol start="7"><li> 以下关于高精度运算的说法错误的是（ ）。</li></ol><p>A.  高精度计算主要是用来处理大整数或需要保留多位小数的运算。</p><p>B.  大整数除以小整数的处理的步骤可以是，将被除数和除数对齐，从左到右逐位尝试将除数乘以某个数，通过减法得到新的被除数，并累加商。</p><p>C.  高精度乘法的运算时间只与参与运算的两个整数中长度较长者的位数有关。</p><p>D.  高精度加法运算的关键在于逐位相加并处理进位。 </p><blockquote><p>答案: C。高精度乘法的运算时间与两个整数的位数的乘积有关，而不仅仅是较长者的位数。位数的增加会导致乘法的复杂度呈指数级增长，需要更多的计算步骤和时间。</p></blockquote><p>8.  后缀表达式“6 2 3 + - 3 8 2 &#x2F; + * 2 ^ 3 +”对应的中缀表达式是（ ）</p><p>A.  <code>((6 - (2 + 3)) * (3 + 8 / 2)) ^ 2 + 3</code></p><p>B. <code>6 - 2 + 3 * 3 + 8 / 2 ^ 2 + 3</code></p><p>C. <code>(6 - (2 + 3)) * ((3 + 8 / 2) ^ 2) + 3</code></p><p>D.  <code>6 - ((2 + 3) * (3 + 8 / 2)) ^ 2 + 3</code></p><blockquote><p>答案: A。根据后缀表达式到中缀表达式的转换规则，我们可以逆序遍历后缀表达式并使用栈来构建中缀表达式。遇到数字时，直接将其入栈；遇到运算符时，从栈中弹出相应数量的操作数，并按照运算在·符和操作数之间的优先级进行括号添加，然后将结果再次入栈。</p><p>对于给定的后缀表达式<code>6 2 3 + - 3 8 2 / + * 2 ^ 3 +</code>，我们可以通过上述方法得到中缀表达式为：<code>((6-(2+3))*(3+(8/2)))^2+3</code></p><p>因此，选项 A. <code>((6 - (2 + 3)) * (3 + 8 / 2)) ^ 2 + 3</code> 是正确的答案。</p></blockquote><ol start="9"><li> 数101010(2)和166(8)的和为（ ）。</li></ol><p>A.  10110000(2)</p><p>B.  236(8)</p><p>C.  158(10)</p><p>D.  A0(16)</p><blockquote><p>答案: D</p><p>将二进制数101010(2)转换为十进制得到42，将八进制数166(8)转换为十进制得到118。</p><p>将十进制数42和118相加得到160。</p><p>现在我们将160转换为十六进制，得到A0(16)。</p><p>因此，正确答案是选项 D. A0(16)。</p></blockquote><ol start="10"><li> 假设有一组字符{a,b,c,d,e,f}，对应的频率分别为5%，9%，12%，13%，16%，45%。请问以下哪个选项是字符a,b,c,d,e,f分别对应的一组哈夫曼编码？（ ）</li></ol><p>A.  1111，1110，101，100，110，0</p><p>B.  1010，1001，1000，011，010，00</p><p>C.  000，001，010，011，10，11</p><p>D.  1010，1011，110，111，00，01</p><blockquote><p>答案: A</p><p>根据哈夫曼编码的生成过程，我们可以按照如下步骤得到字符a,b,c,d,e,f分别对应的哈夫曼编码：</p><ol><li>将所有字符按照出现频率从小到大排序，得到字符序列{a,b,c,d,e,f}。</li><li>取出频率最小的两个字符a和b，构建一棵二叉树，并将其根节点的频率设置为a和b的频率之和（即5%+9%&#x3D;14%）。</li><li>将原序列中的a和b删除，并将新生成的节点插入到序列中，得到新的字符序列{c,d,e,f,ab}。</li><li>重复步骤2和3，直到得到一棵包含所有字符的二叉树。</li><li>对于每条从根节点到叶子节点的路径，用0表示向左走，用1表示向右走，得到对应字符的哈夫曼编码。</li></ol></blockquote><p>按照上述算法，我们可以得到如下结果：</p><table><thead><tr><th>字符</th><th>频率</th><th>哈夫曼编码</th></tr></thead><tbody><tr><td>a</td><td>5%</td><td>1111</td></tr><tr><td>b</td><td>9%</td><td>1110</td></tr><tr><td>c</td><td>12%</td><td>101</td></tr><tr><td>d</td><td>13%</td><td>100</td></tr><tr><td>e</td><td>16%</td><td>110</td></tr><tr><td>f</td><td>45%</td><td>0</td></tr></tbody></table><blockquote><p>因此，正确答案是选项 A. 1111，1110，101，100，110，0。</p></blockquote><ol start="11"><li> 给定一棵二叉树，其前序遍历结果为：ABDECFG，中序遍历结果为：DEBACFG。请问这棵树的正确后序遍历结果是什么？（ ）</li></ol><p>A.  EDBFGCA</p><p>B.  EDBGCFA</p><p>C.  DEBGFCA</p><p>D.  DBEGFCA</p><blockquote><p>答案: A</p><p>根据前序遍历结果和中序遍历结果重构二叉树的步骤如下：</p><ol><li>前序遍历结果的第一个字符为根节点，即A。</li><li>在中序遍历结果中找到根节点A，将其左边的字符为左子树的中序遍历结果，右边的字符为右子树的中序遍历结果。根据此规则，我们可以得到左子树的中序遍历结果为DEB，右子树的中序遍历结果为CFG。</li></ol></blockquote><ol><li>根据左子树的中序遍历结果DEB和左子树的前序遍历结果ABD，递归重构左子树。结果如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    A  </span><br><span class="line">   / \  </span><br><span class="line">  B   F  </span><br><span class="line"> / \  </span><br><span class="line">D   E  </span><br></pre></td></tr></table></figure><ol start="2"><li>根据右子树的中序遍历结果CFG和右子树的前序遍历结果CFG，递归重构右子树。结果如下：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  G  </span><br><span class="line"> / \  </span><br><span class="line">C   G</span><br></pre></td></tr></table></figure><ol start="3"><li>将左子树和右子树连接到根节点上，得到整棵树的结构：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  A  </span><br><span class="line"> / \  </span><br><span class="line">B   F  </span><br><span class="line">   / \  </span><br><span class="line">  D   E  </span><br><span class="line">     / \  </span><br><span class="line">    C   G</span><br></pre></td></tr></table></figure><blockquote><p>根据后序遍历的性质，在后序遍历中，左子树先于右子树被访问，根节点最后被访问。因此，这棵树的正确后序遍历结果是EDBFGCA。</p><p>因此，正确答案是选项 A. EDBFGCA。</p></blockquote><ol start="12"><li> 考虑一个有向无环图，该图包括4条有向边：(1,2)，(1,3)，(2,4)，和(3,4)。以下哪个选项是这个有向无环图的一个有效的拓扑排序？（ ）</li></ol><p>A.  4，2，3，1</p><p>B.  1，2，3，4</p><p>C.  1，2，4，3</p><p>D.  2，1，3，4</p><blockquote><p>答案: B。拓扑排序是有向无环图中对顶点进行排序的一种方法，使得所有的有向边从排在前面的顶点指向排在后面的顶点。根据提供的有向边 (1,2)，(1,3)，(2,4)，和(3,4)，我们可以确定拓扑排序的正确选项。</p><p>根据题目给出的有向边，可以得出以下关系：  </p><ul><li>1 -&gt; 2</li><li>1 -&gt; 3</li><li>2 -&gt; 4</li><li>3 -&gt; 4</li></ul><p>根据拓扑排序的定义，我们需要先排列没有前置依赖的顶点。根据上述关系，只有顶点 1 没有前置依赖，所以它必须是拓扑排序的第一个顶点。  </p><p>接下来，根据关系 (1,2) 和 (1,3)，顶点 2 和 3 是直接依赖于顶点 1 的，它们应该在 1 后面。  </p><p>最后，根据关系 (2,4) 和 (3,4)，顶点 4 是直接依赖于顶点 2 和 3 的，所以它们也应该在 2 和 3 后面。  </p><p>综上所述，有效的拓扑排序应该是 B. 1，2，3，4。</p></blockquote><ol start="13"><li> 在计算机中，以下哪个选项描述的数据存储容量最小？（ ）</li></ol><p>A.  字节（byte）</p><p>B.  比特（bit）</p><p>C.  字（word）</p><p>D.  千字节（kilobyte）</p><blockquote><p>答案: B在计算机中，以下选项描述的数据存储容量最小是B. 比特（bit）。</p><p>比特（bit）是计算机中最基本的单位，用来表示二进制数据的单个位，可以取0或1两个值。比特是计算机中最小的存储单位。</p><p>字节（byte）是计算机中常用的数据存储单位，它由8个比特组成，可以用来表示一个字符或8个二进制位。字节是相对于比特来说更常用的单位。</p><p>字（word）通常指计算机中一个机器字的大小，表示计算机一次能够处理的二进制位数，其大小由机器的架构决定。</p><p>千字节（kilobyte）是计算机中常用的数据存储容量单位，等于1024字节，用来表示较小的数据量。</p><p>因此，在计算机中，<strong>比特</strong>是描述数据存储容量最小的单位。</p></blockquote><ol start="14"><li> 一个班级有10个男生和12个女生。如果要选出一个3人的小组，并且小组中必须至少包含1个女生，那么有多少种可能的组合？（ ）</li></ol><p>A.  1420</p><p>B.  1770</p><p>C.  1540</p><p>D.  2200</p><blockquote><p>答案: A。要选出一个3人的小组，并且小组中必须至少包含1个女生。</p><p>情况一：选取1个女生和2个男生。  </p><p>选择女生的方式有 12 种，选择男生的方式有 $C_{10}^2 &#x3D; 45$ 种。总共的组合方式为 12 * 45 &#x3D; 540 种。</p><p>情况二：选取2个女生和1个男生。  选择女生的方式有 $C_{12}^2 &#x3D; 66$ 种，选择男生的方式有 10 种。总共的组合方式为 66 * 10 &#x3D; 660 种。</p><p>情况三：选取3个女生。  选择女生的方式有 $C_{12}^3 &#x3D; 220$ 种。总共的组合方式为 220 种。</p><p>综上所述，总共的可能的组合方式为 540 + 660 + 220 &#x3D; 1420 种。  </p></blockquote><ol start="15"><li> 以下哪个不是操作系统？（ ）</li></ol><p>A.  Linux</p><p>B.  Windows</p><p>C.  Android</p><p>D.  HTML</p><blockquote><p>答案: D</p><p>HTML（超文本标记语言）是一种用于创建网页的标记语言，它并不是操作系统。HTML主要用于描述网页的结构和内容，而不是提供操作系统所需的核心功能，如管理资源、调度任务和控制硬件等。</p><p>Linux、Windows和Android都是常见的操作系统。Linux是一种开源的操作系统，被广泛应用于服务器和嵌入式设备等领域。Windows是由微软公司开发的操作系统，用于个人电脑和服务器等。Android是由谷歌开发的移动设备操作系统，用于智能手机、平板电脑等移动设备。  </p></blockquote><hr><h1 id="二、阅读程序"><a href="#二、阅读程序" class="headerlink" title="二、阅读程序"></a>二、阅读程序</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;、</span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">f</span><span class="params">(<span class="type">double</span> a,<span class="type">double</span> b,<span class="type">double</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">double</span> s=(a+b+c)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(s*(s-a)*(s-b)*(s-c));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   cout.<span class="built_in">flags</span>(ios::fixed);</span><br><span class="line">   cout.<span class="built_in">precision</span>(<span class="number">4</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="type">int</span> a,b,c;</span><br><span class="line">   cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">   cout&lt;&lt;<span class="built_in">f</span>(a,b,c)&lt;&lt;endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>题目解析：本题是求三角形面积的海伦公式，即给出三角形的三边长a，b，c，利用第7行给出的公式，即可方便地求出三角形的面积。</p></blockquote><p>假设输入的所有数都为不超过 10001000 的正整数，完成下面的判断题和单选题：</p><h3 id="判断题"><a href="#判断题" class="headerlink" title="判断题"></a>判断题</h3><p>1、（2分）当输入为 <code>2 2 2</code> 时，输出为<code>1.7321</code>（ 对 ）</p><blockquote><p>$\sqrt3 &#x3D; 1.732050807568877$，四舍五入就是1.7321。</p></blockquote><p>2、（2分）将第7行中的 <code>(s-b)*(s-c)</code> 改为 <code>(s-c)*(s-b)</code> 不会影响程序运行的结果（ 对 ）</p><p>3、（2分）程序总是输出四位小数（ 错 ）</p><blockquote><p>如果a、b、c不能构成三角形，根号下可能为负数，不能正常运行。</p></blockquote><h3 id="单选题"><a href="#单选题" class="headerlink" title="单选题"></a>单选题</h3><p>4、当输入为 <code>3 4 5</code> 时，输出为（ ）</p><p>A.<code>6.0000</code></p><p>B. <code>12.0000</code></p><p>C. <code>24.0000</code></p><p>D. <code>30.0000</code></p><blockquote><p>选A。$6 \times 3 \times 2 \times 1 &#x3D; 36，\sqrt{36} &#x3D; 6$。</p></blockquote><p>5、当输入为 <code>5 12 13</code> 时，输出为（ ）</p><p>A. <code>24.0000</code></p><p>B. <code>30.0000</code></p><p>C. <code>60.0000</code></p><p>D.<code>120.0000</code></p><blockquote><p>选B。</p></blockquote><h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(string x,string y)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m=x.<span class="built_in">size</span>();</span><br><span class="line">    <span class="type">int</span> n=y.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;<span class="built_in">v</span>(m+<span class="number">1</span>,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">   <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(x[i<span class="number">-1</span>]==y[j<span class="number">-1</span>])&#123;</span><br><span class="line">                v[i][j]=v[i<span class="number">-1</span>][j<span class="number">-1</span>]+<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                v[i][j]=<span class="built_in">max</span>(v[i<span class="number">-1</span>][j],v[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v[m][n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">g</span><span class="params">(string x,string y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x.<span class="built_in">size</span>() != y.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">f</span>(x+x,y)==y.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string x,y;</span><br><span class="line">    cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">g</span>(x,y)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>本题的f函数为【最长公共子序列】问题的模板程序。即可以求出两个字符串共同含有的子串里，最长的子串的长度。注意子串不一定取连续的字母，但是顺序必须和原始顺序保持一致。</p></blockquote><h3 id="判断题-1"><a href="#判断题-1" class="headerlink" title="判断题"></a>判断题</h3><p>1、f 函数的返回值小于等于 min{n,m}。（ 对 ）</p><p>2、f 函数的返回值等于两个输入字符串的最长公共子串的长度。（ 错 ）</p><p>3、当输入两个完全相同的字符串时，g 函数的返回值总是 true。（ 对 ）</p><h3 id="单选题-1"><a href="#单选题-1" class="headerlink" title="单选题"></a>单选题</h3><p>4、将第19行中的 <code>v[m][n]</code> 替换为 <code>v[n][m]</code>，那么该程序（）。</p><p>A. 行为不变</p><p>B. 只会改变输出</p><p>C. 一定非正常退出</p><p>D. 可能非正常退出</p><p>5、当输入为 csp-j p-jcs 时，输出为（）。</p><p>A. 0 </p><p>B. 1</p><p>C. T</p><p>D. F</p><p>6、当输入为 csppsc spsccp 时，输出为（）。<br>A. T</p><p>B. F</p><p>C. 0</p><p>D. 1</p><hr><p>参考</p><ul><li><p><a href="https://mp.weixin.qq.com/s/QnoyNzhxd8D6Zo3WkmurhA">(CSP-J1) 入门级 C++语言试题 (qq.com)</a></p></li><li><p><a href="https://ti.luogu.com.cn/problemset/1041">1041 - CSP 2023 入门级第一轮 - 洛谷有题 (luogu.com.cn)</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/656968166">【零一原创】2023 CSP-J组第一轮初赛真题答案及全面解析 - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://www.cnblogs.com/23lalala/archive/2012/09/26/2703595.html">求三叉树高度 - 23lalala - 博客园 (cnblogs.com)</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2023CSP-J1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017NOIP普及组初赛真题</title>
      <link href="/2023/09/06/2017NOIP%E6%99%AE%E5%8F%8A%E7%BB%84%E5%88%9D%E8%B5%9B%E7%9C%9F%E9%A2%98/"/>
      <url>/2023/09/06/2017NOIP%E6%99%AE%E5%8F%8A%E7%BB%84%E5%88%9D%E8%B5%9B%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、单项选择题"><a href="#一、单项选择题" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h1><p>1.在8位二进制补码中，10101011表示的数是十进制下的（ ）</p><p>A．43 </p><p>B. -85 </p><p>C. -43 </p><p>D. -84</p><blockquote><p>选B。</p><p>反码+1——&gt;补码，第一位是0则表示正数，1表示负数</p><p>得出补码的反码：10101011 - 1 &#x3D; 10101010</p><p>对应负数的绝对值的原码则为1 + 0 + 4 + 0 + 16 + 0 + 64 &#x3D; 85</p><p>因为是负数，所以是-85。</p></blockquote><p>2.计算机存储数据的基本单位是（ ）</p><p>A. bit </p><p>B. Byte </p><p>C. GB </p><p>D. KB</p><blockquote><p>选B。在计算机中，数据存储的基本单位是字节（Byte）。一个字节由8个二进制位（Bit）组成，每一位可以表示0或1两种状态。因为计算机是以二进制来处理和存储数据的，所以需要将这些数据以字节为单位进行存储。</p><p>而KB、MB、GB等都是衡量数据量的单位，它们分别等于1024字节、1024KB、1024MB。例如，1MB等于1024KB，1KB等于1024字节。这些都是以2的幂次方来定义的，反映了计算机硬件系统的特点。</p></blockquote><p>3.下列协议中与电子邮件无关的是（ ）</p><p>A. POP3 </p><p>B. SMTP </p><p>C WTO </p><p>D IMAP</p><blockquote><p>选C。</p><p>WTO:世界贸易组织World Trade Organization。</p><p>POP3:是Post Office Protocol 3的简称，即邮件协议的第3个版本。</p><p>SMTP:全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。</p><p>IMAP:全称是Internet Mail Access Protocol,即交互式邮件存取协议。</p></blockquote><p>4.分辨率为800*600、16位色的位图，存储图像信息所需的空间为（ ）</p><p>A. 937.5KB </p><p>B. 4218.75KB </p><p>C. 4320KB </p><p>D. 2880KB</p><blockquote><p>选A。</p><p>16位色图的意思是用2的16次方表示一个颜色。用2个byte表示1个点，共有800*600个点。</p><ol><li>600*800 &#x3D; 480000。</li><li>2个byte表示1个点 –&gt; 960000。</li><li>除以1024,单位是KB –&gt; 937.5。</li></ol></blockquote><p>5.计算机应用的最早领域是（ ）</p><p>A. 数值计算 </p><p>B. 人工智能 </p><p>C. 机器人</p><p>D. 过程控制</p><blockquote><p>选A。计算机是为了计算的需要而发明的，第一代电子计算机也是为计算弹道和射击表而设计的，所以，计算机最早的应用领域就应该是数值计算。</p></blockquote><p>6.下列不属于面向对象程序设计语言的是（ ）<br>A. C </p><p>B. C++ </p><p>C. Java </p><p>D. C#</p><blockquote><p>选A。</p><p>解析：面向对象程序设计语言是一类以对象作为基本程序结构单位的程序设计语言，指用于描述的设计是以对象为核心，而对象是程序运行时刻的基本成分。语言中提供了类、继承等成分，有识认性、多态性、类别性和继承性四个主要特点。</p></blockquote><p>7.NOI的中文意思是（ ）</p><p>A. 中国信息学联赛 </p><p>B. 全国青少年信息学奥林匹克竞赛</p><p>C. 中国青少年信息学奥林匹克竞赛 </p><p>D. 中国计算机学会</p><blockquote><p>选B。NOl：全称National Olympiad Informatics,意思是全国青少年信息学奥林匹克竞赛。</p></blockquote><p>8.2017年10月1日是星期日，1999年10月1日是（ ）</p><p>A. 星期三 </p><p>B.星期日 </p><p>C. 星期五 </p><p>D.星期二</p><blockquote><p>选C。</p><p>十月一日周日，十月八日也是周日。</p><p>1999——&gt;2017共18年，平年每年365天，闰年每年366天。</p><p>1999—―&gt;2017年一共5个闰年ト，分别是2000、2004、2008、2012、2016。</p><p>（18*365+5）&#x2F;7&#x3D;939…2，往回推两天，比如2017年9月29日，也是余2天，是周五。</p></blockquote><p>9.甲、乙、丙三位同学选修课程，从4门课程中，甲选修2门，乙、丙各选修3门，则不同的选修方案共有（ ）</p><p>A. 36 </p><p>B. 48</p><p>C. 96 </p><p>D. 192</p><blockquote><p>选C。</p><p>分步</p><ol><li>甲：$C_4^2$</li><li>乙：$C_4^3$</li><li>丙：$C_4^3$</li></ol><p>共 6 * 4 * 4 &#x3D; 96。</p></blockquote><p>10.设G是有n个结点、m条边（n≤m）的连通图，必须删去G的（ ）条边，才能使得G变成一棵树。</p><p>A. m-n+1 </p><p>B. m-n </p><p>C. m+n+1 </p><p>D. n-m+1</p><blockquote><p>选A。若结点为n，树有n - 1条边。把这个图变成树，即变成n - 1条边，需要删掉 <code>m - (n - 1) = m - n + 1</code> 条边。</p></blockquote><p>11.对于给定的序列｛$a_k$｝,我们把（i , j）称为逆序对当且仅当 i &lt; j且 $a_i$  &gt; $a_j$ .那么序列1，7，2，3，5，4的逆序对数为（ ）个</p><p>A. 4 </p><p>B. 5 </p><p>C. 6 </p><p>D. 7</p><blockquote><p>选B。逐个枚举。</p><ul><li>1：后面没有比1小的。</li><li>7：后面都比7小，有4个逆序对。</li><li>2：没有。</li><li>3：没有。</li><li>5：后面的4比5小，有1个逆序对。</li></ul><p>逆序对共5对。</p></blockquote><p>12.表达式<code>a*(b+c)*d</code>的后缀形式是（ ）</p><p>A. <code>abcd*+*</code></p><p>B. <code>abc+*d*</code></p><p>C. <code>a*bc+*d</code></p><p>D. <code>b+c*a*d</code></p><blockquote><p>选B。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 先算括号里的</span><br><span class="line">b c +</span><br><span class="line">a b c + * </span><br><span class="line">a b c + * d *</span><br></pre></td></tr></table></figure><p>13.向一个栈顶指针为hs的链式栈中插入一个指针s指向的结点时，应执行（ ）</p><p>A. hs-&gt;next &#x3D;s ;</p><p>B. s-&gt;next&#x3D;hs; hs&#x3D;s ;</p><p>C. s-&gt;next&#x3D;hs-&gt;next;hs-&gt;next&#x3D;s;</p><p>D. s-&gt;next&#x3D;hs; hs&#x3D;hs-&gt;next;</p><blockquote><p>选B。s插入成为栈顶，栈顶指针再指向s。</p></blockquote><p>14.若串S&#x3D;“copyright”，其子串的个数是（ ）<br>A. 72 B. 45 C. 46 D. 36</p><p>15.十进制小数13.375对应的二进制数是（ ）<br>A. 1101.011 B. 10111.011 C. 1101.101 D. 1010.01</p><p>16.对于入栈顺序为a,b,c,d,e,f,g的序列，下列（ ）不可能是合法的出栈序列<br>A. a,b,c,d,e,f,g B. a,d,c,b,e,g,f C. a,d,b,c,g,f,e D. g,f,e,d,c,b,a</p><p>17.设A和B是两个长为n的有序数组，现在需要将A和B合并成一个排好序的数组，任何以元素比较作为基本运算的归并算法在最坏情况下至少要做（ ）次比较<br>A. n2 B. n log n C. 2n D. 2n-1</p><p>18.从（ ）年开始，NOIP竞赛将不再支持Pascal语言<br>A. 2020 B. 2021 C. 2022 D. 2023</p><p>19.一家四口人，至少两个人生日属于同一月份的概率是（ )<br>(假定每个人生日属于每个月份的概率相同且不同人之间相互独立)<br>A. 1&#x2F;12 B. 1&#x2F;144 C. 41&#x2F;96 D. 3&#x2F;4</p><p>20.以下和计算机领域密切相关的奖项是（ ）<br>A． 奥斯卡奖 B. 图灵奖 C. 诺贝尔奖 D. 普利策奖</p><hr><p>参考</p><ul><li><a href="https://ti.luogu.com.cn/problemset/1021">1021 - NOIP 2017 普及组初赛试题 - 洛谷有题 (luogu.com.cn)</a></li><li><a href="https://www.bilibili.com/video/BV1WT411A7Ww/?spm_id_from=333.788&vd_source=49e30194f6d5798a1f90d69dad9c0460">2017年NOIP普及组初赛真题讲解_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2017CSP-J1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP-J高频考点-排列组合</title>
      <link href="/2023/08/31/CSP-J%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"/>
      <url>/2023/08/31/CSP-J%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9-%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/</url>
      
        <content type="html"><![CDATA[<h1 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h1><p>排列组合考的不是计算，而是逻辑思维。</p><h2 id="分类加法计数原理"><a href="#分类加法计数原理" class="headerlink" title="分类加法计数原理"></a>分类加法计数原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A --&gt;|3趟飞机航班| B</span><br><span class="line">A --&gt;|4列火车| B</span><br><span class="line">A --&gt;|2艘船| B</span><br></pre></td></tr></table></figure><p>从A地到B地一共有 <code>3 + 4 + 2 = 9</code>种方案。</p><h2 id="分步乘法计数原理"><a href="#分步乘法计数原理" class="headerlink" title="分步乘法计数原理"></a>分步乘法计数原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line">A --&gt;|a| B</span><br><span class="line">A --&gt;|b| B</span><br><span class="line">B --&gt;|c| C</span><br><span class="line">B --&gt;|d| C</span><br><span class="line">B --&gt;|e| C</span><br></pre></td></tr></table></figure><p>从A地到C地，需要先经过B地。</p><ul><li>A地到B地有2种方法</li><li>B地到C地有3种方法</li></ul><p>共有<code>2 * 3 = 6</code>种方法。该题分步来进行，第一步从A地到B地，第二步从B地到C地，每一步的方案数相乘。</p><p>可以逐个枚举试一下</p><ol><li><p>A地到B地经过路径a</p><ul><li>ac、ad、ae</li></ul></li><li><p>A地到B地经过路径b</p><ul><li>bc、bd、be</li></ul></li></ol><h1 id="常见题型"><a href="#常见题型" class="headerlink" title="常见题型"></a>常见题型</h1><h2 id="一、特殊元素优先安排"><a href="#一、特殊元素优先安排" class="headerlink" title="一、特殊元素优先安排"></a>一、特殊元素优先安排</h2><p>例1：六个人从左至右排成一行，最左端只能排甲或乙，最右端不能排甲，有多少种排法?</p><blockquote><p>特殊元素使<strong>最左端</strong>和<strong>最右端</strong>，那么先选最左端，再选最右端，最后选其余4个位置。（先右后左也行）</p><ol><li>最左端有两种选法。</li><li>此时选最右端就有问题：如果最左端是甲，最右端有<strong>5种选法</strong>；如果最左端是乙，最右端<strong>不能排甲</strong>，有<strong>4种选法</strong>。</li></ol></blockquote><table><thead><tr><th>甲</th><th>*</th><th>*</th><th>*</th><th>*</th><th>5种选法</th></tr></thead><tbody><tr><td>乙</td><td>*</td><td>*</td><td>*</td><td>*</td><td>4种选法</td></tr></tbody></table><blockquote><p>遇到这种情况：有两种不一样方案，就需要分类。</p><p>做题时不需要一开始就想怎么分类，按正常的步骤去做，遇到<strong>有不确定的方案</strong>时，再去分类。</p></blockquote><p>分成两类，第一类最左端为<strong>甲</strong>，第二类最右端为<strong>乙</strong>。最左端已经确定，不需要再选了。步骤变成：先选最右端，最后选其余4个位置。</p><ul><li>第一类<ol><li>最右端：5种</li><li>其余4人：$A_4^4$</li></ol></li></ul><table><thead><tr><th>甲</th><th>*</th><th>*</th><th>*</th><th>*</th><th>5种选法</th></tr></thead></table><ul><li>第二类<ol><li>最右端：4种</li><li>其余4人：$A_4^4$</li></ol></li></ul><table><thead><tr><th>乙</th><th>*</th><th>*</th><th>*</th><th>*</th><th>4种选法</th></tr></thead></table><blockquote><p>故结果为 $5 \times A_4^4 + 4 \times A_4^4$。</p></blockquote><h3 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h3><p>1、用0，1，2，3，4组成一个无重复数字的五位偶数有多少个？</p><p>2、A B C D E 5个人出4个人完成 a b c d 四项工作，出任务的4人每人完成一个工作，每个工作安排给一个人，</p><p>其中 A B 只会做 a b 这两种工作，其余人可以胜任所有工作，有多少种不同的安排任务的方式？</p><p>3、有5张卡片，正反两面分别写有数字0与1，2与3，4与5，6与7，8与9，先从中取出3张排成一列，可以摆成多少个不同的三位数？</p><hr><hr><p>解析分割线</p><hr><hr><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>1、用0，1，2，3，4组成一个无重复数字的五位偶数有多少个？</p><blockquote><p>五位数，<strong>首位</strong>不能为0，<strong>最后一位</strong>只能为0、2、4，该题是<strong>特殊元素优先安排</strong>。</p><ol><li>先选<strong>最后一位</strong></li><li>再选<strong>首位</strong></li><li>最后选其余的位。</li></ol></blockquote><table><thead><tr><th>4种</th><th>*</th><th>*</th><th>*</th><th>0</th></tr></thead><tbody><tr><td>3种</td><td>*</td><td>*</td><td>*</td><td>2 | 4</td></tr></tbody></table><blockquote><p>最后一位如果为<strong>0</strong>，首位无影响，有4种；最后一位为<strong>2或4</strong>，首位不能为0，只有3种。</p></blockquote><p>那么分成两类</p><ul><li>第一类：最后一位为0<ol><li>首位无影响，跟其余位一起算，$A_4^4$</li></ol></li></ul><table><thead><tr><th>4种</th><th>*</th><th>*</th><th>*</th><th>0</th></tr></thead></table><ul><li>第二类<ol><li>最后一位：2种</li><li>首位：3种</li><li>其余3位：$A_3^3$</li></ol></li></ul><table><thead><tr><th>3种</th><th>*</th><th>*</th><th>*</th><th>2 | 4</th></tr></thead></table><blockquote><p>故$2 \times 3 \times A_3^3 + A_4^4$。</p></blockquote><hr><p>2、A B C D E 5个人出4个人完成 a b c d 四项工作，出任务的4人每人完成一个工作，每个工作安排给一个人，</p><p>其中 A B 只会做 a b 这两种工作，其余人可以胜任所有工作，有多少种不同的安排任务的方式？</p><blockquote><p>这些题都有两种切入角度：</p><p>第一种：人选工作</p><ul><li>分成3类：<ul><li>A，C，D，E</li><li>B，C，D，E</li><li>A，B，<code>*</code>，<code>*</code></li></ul></li><li>然后再去分配工作。</li></ul><p>第二种：工作选人</p><ul><li>此时特殊元素是<strong>c、d</strong>。因为a、b这两个工作谁都能做，c、d工作只有C、D、E能做。</li></ul><p>只需要两步，先确定特殊元素，再确定其余元素。</p><ol><li>给c、d选人：从C、D、E里选两个人，$A_3^2$</li><li>给a、b选人：从剩余的3人里选两个人，$A_3^2$</li></ol><p>故$A_3^2 \times A_3^2$。</p></blockquote><p>3、有5张卡片，正反两面分别写有数字0与1，2与3，4与5，6与7，8与9，先从中取出3张排成一列，可以摆成多少个不同的三位数？</p><blockquote><p>如果按着题目走，先从5张卡片里选3张，再排列，然后卡片正面还是反面，还要判断<code>0|1</code>这张卡片，十分难做。</p><p>那么可以跟第2题一样想，换一个切入角度，跳出题目的场景，位置选数，给这三位数<strong>逐位</strong>选数字：</p><ol><li>选百位：0不能选，有9种。</li><li>选十位：百位数消耗了1张卡片，剩4张卡片，只有8个数字，有8种。</li><li>选个位：百位、十位消耗了2张卡片，剩3张卡片，只有6个数字，有6种。</li></ol><p>故结果为$9 \times 8 \times 6$。</p></blockquote><h2 id="二、捆绑法"><a href="#二、捆绑法" class="headerlink" title="二、捆绑法"></a>二、捆绑法</h2><ul><li>特点：元素需要<strong>相邻</strong>。</li></ul><p>例题：7人站成一排，其中甲乙相邻且丙丁相邻，共有多少种不同的排法？</p><blockquote><p>将相邻的两个人看作<strong>一个人</strong>，相当于绑起来。相邻的两个人是有顺序的：甲乙、乙甲，要乘2。</p><ol><li>甲乙捆：2种</li><li>丙丁捆：2种</li><li>全部一起排：此时相当于5个人，$A_5^5$</li></ol><p>故结果为$2 \times 2 \times A_5^5$</p></blockquote><h3 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h3><p>1、一排9个座位坐了3个三口之家，若每家人坐在一起，则不同的坐法种数为？</p><p>2、8个车位，5辆不同的车，车全停一起多少种停法?空车位全在一起多少种停法？</p><hr><hr><p>解析分割线</p><hr><hr><h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>1、一排9个座位坐了3个三口之家，若每家人坐在一起，则不同的坐法种数为？</p><table><thead><tr><th>a1 a2 a3</th><th>b1 b2 b3</th><th>c1 c2 c3</th></tr></thead></table><blockquote><p>将同一家的人捆在一起</p><ol><li>a1 a2 a3：$A_3^3$</li><li>b1 b2 b3：$A_3^3$</li><li>c1 c2 c3：$A_3^3$</li><li>全部一起排：$A_3^3$</li></ol></blockquote><p>2、8个车位，5辆不同的车，车全停一起多少种停法？空车位全在一起多少种停法？</p><blockquote><p>车全停一起</p><ol><li>5辆车捆：$A_5^5$</li><li>停大车：4种</li></ol><p>空车位停一起</p><ol><li>3个空车位捆：空车位之间一样，调换顺序没有区别，1种</li><li>全部排：3个空车位看作一个，相当于6，$A_6^6$</li></ol></blockquote><h2 id="三、插空法"><a href="#三、插空法" class="headerlink" title="三、插空法"></a>三、插空法</h2><p>特点：元素需要<strong>不相邻</strong>。</p><p>例题：某班新年联欢会原定的5个节目已排成节目单，开演前又增加了两个新节目。如果将这两个新节目插入原节目单中，那么不同插法的种数为？且两个新节目不相邻，那么不同插法的种数为?</p><blockquote><p>直接插入无要求：第一个节目从6个空插入有6种；第二个节目插入时，此时多了一个节目，有7个空，插入有7种。</p><p>不相邻：5个节目有6个空隙，从6个空里插两个节目，$A_6^2$。</p></blockquote><h3 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h3><p>1、4个男生，3个女生站成一排，三个女生中有且只有两个女生相邻，多少种不同的排法？</p><p>2、8个车位，5辆不同的车，只有空车位互不相邻在一起多少种停法？只有2个空车位在一起多少种停法?</p><hr><hr><p>解析分割线</p><hr><hr><h3 id="解析-2"><a href="#解析-2" class="headerlink" title="解析"></a>解析</h3><p>1、4个男生，3个女生站成一排，三个女生中有且只有两个女生相邻，多少种不同的排法？</p><blockquote><p>2个女生相邻，剩下的一个女生不能与这2个女生相邻，就有不相邻了。</p><ol><li>4个男生：$A_4^4$</li><li>3个女生选2个捆：$A_3^2$</li><li>插空：$A_5^2$</li></ol></blockquote><p>2、8个车位，5辆不同的车，只有空车位互不相邻在一起多少种停法？只有2个空车位在一起多少种停法?</p><blockquote><p>空车位互不相邻：</p><ol><li>排5辆车：$A_5^5$</li><li>插空：空车位调换没有影响，$C_6^3$</li></ol><p>只有2个空车位相邻：</p><ol><li>排5辆车：$A_5^5$</li><li>绑2空车位：空车位一样，没有顺序，1种</li><li>6空隙插空：插入两个元素：两个空车位、一个空车位，此时这两个元素不一样，$A_6^2$</li></ol></blockquote><hr><h2 id="四、定序问题-相同元素排列问题"><a href="#四、定序问题-相同元素排列问题" class="headerlink" title="四、定序问题 &amp; 相同元素排列问题"></a>四、定序问题 &amp; 相同元素排列问题</h2><ul><li>定序问题：部分元素<strong>顺序已经定好</strong>，<strong>只选不排</strong>。</li><li>相同元素排列问题：部分元素<strong>相同</strong>，没有顺序，<strong>只选不排</strong>。</li></ul><p>例题1：7个人排队，其中甲在乙前面，乙在丙前面。</p><blockquote><ol><li>甲乙丙三人选位置：$C_7^3$</li><li>甲乙丙：三人的顺序已经定好，只有1种</li><li>余4人：$A_4^4$</li></ol></blockquote><p>例题2：<code>1 1 1 2 3</code>组成5位数，几种可能？</p><blockquote><ol><li>给三个<code>1</code>选三个位置：$C_5^3$</li><li>三个<code>1</code>：交换没有区别，1种</li><li>余2个：$A_2^2$</li></ol></blockquote><h3 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h3><p>1、某工程队有6项工程需要单独完成，其中工程乙必须在工程甲完成之后才能进行，工程丙必须在工程乙完成之后才能进行，工程丁必须在工程丙完成之后立即进行，共有多少种方案？</p><p>2、三位数中，123叫做严格递增数，530叫做严格递减数，严格单调3位数有多少个？</p><p>3、7人身高不同，排成一排，中间最高，两侧依次降低，多少种排法？</p><p>4、把good写错多少种方法?把error写错多少种方法?</p><hr><hr><p>解析分割线</p><hr><hr><h3 id="解析-3"><a href="#解析-3" class="headerlink" title="解析"></a>解析</h3><p>1、某工程队有6项工程需要单独完成，其中工程乙必须在工程甲完成之后才能进行，工程丙必须在工程乙完成之后才能进行，工程丁必须在工程丙完成之后立即进行，共有多少种方案？</p><blockquote><p>甲 –&gt; 乙 –&gt; 丙丁，丙丁看作一个工程。</p><ol><li>3个工程选：$C_5^3$</li><li>3个工程：顺序已经定好，1种</li><li>余2：$A_2^2$</li></ol></blockquote><p>2、三位数中，123叫做严格递增数，530叫做严格递减数，严格单调3位数有多少个？</p><blockquote><p>递<strong>减</strong>数：</p><ol><li>从10个里选3个：$C_{10}^3$</li><li>这3个数需要递减，只有1种</li></ol><p>递<strong>增</strong>数：</p><ol><li>从10个里选3个：0不能选，剩9个数，$C_{9}^3$</li><li>这3个数需要递增，只有1种</li></ol><p>故$C_{10}^3 + C_{9}^3$。</p></blockquote><p>3、7人身高不同，排成一排，中间最高，两侧依次降低，多少种排法？</p><table><thead><tr><th></th><th></th><th></th><th>最高</th><th></th><th></th><th></th></tr></thead></table><blockquote><p>中间只能是最高的一个，只有1种，没得选。</p><ol><li>选左边3人：$C_6^3$</li><li>选右边3人：$C_3^3$</li></ol><p>顺序已经定好了，只能向两侧依次降低，只有1种。</p><p>故$C_6^3$。</p></blockquote><p>4、把good写错多少种方法?把error写错多少种方法？</p><blockquote><p>good：$C_4^2 A_2^2 - 1$</p><p>error： $C_5^3 A_2^2 - 1$</p></blockquote><h2 id="五、挡板法"><a href="#五、挡板法" class="headerlink" title="五、挡板法"></a>五、挡板法</h2><p>特点：<strong>相同</strong>的元素<strong>分成n份</strong>，1份至少m个。</p><p>例题：6个相同的苹果，分给3人，每人至少有1个苹果，有几种分法？</p><blockquote><p>将苹果分成3份，需要2个挡板。</p><p><code>1 2 | 3 4 | 5 6</code> </p><p>6个苹果中间有5个位置可以放挡板，故$C_5^2$</p></blockquote><h3 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h3><p>1、12个苹果分给3个人，每个人<strong>至少3个</strong>，多少种分法?</p><p>2、9个运动员名额分给1班2班3班，要求每个班所得名额不少于自己班级序号，多少种分法?</p><hr><hr><p>解析分割线</p><hr><hr><h3 id="解析-4"><a href="#解析-4" class="headerlink" title="解析"></a>解析</h3><p>1、12个苹果分给3个人，每个人至少3个，多少种分法?</p><blockquote><p>三个人分别给<strong>两个</strong>苹果，问题就转换成6个苹果给3人，每人至少1个，$C_5^3$</p></blockquote><p>2、9个运动员名额分给1班2班3班，要求每个班所得名额不少于自己班级序号，多少种分法?</p><blockquote><p>2班给1个名额，3班给2个名额，问题转换成6个名额给3个班，至少1个，$C_5^2$</p></blockquote><h2 id="六、分组问题"><a href="#六、分组问题" class="headerlink" title="六、分组问题"></a>六、分组问题</h2><p>特点：多个元素分成n组。</p><p>平均分组：出现m个组元素个数一样，除以$A_m^m$。</p><p>例题1：6本书，分成3组，第一组1本书，第二组2本书，第三组3本书，有几种分法？</p><blockquote><ol><li>第一组$C_6^1$</li><li>第二组$C_5^2$</li><li>第三组$C_3^3$</li></ol><p>故$C_6^1 C_5^2 C_3^3$。</p></blockquote><p>例题2：6本书，分成3组，每组2本书，有几种分法？</p><blockquote><p>平均分组，三组都是一样的，没有顺序，继续按例1的方法统计，会重复。</p></blockquote><table><thead><tr><th>ab</th><th>cd</th><th>ef</th></tr></thead><tbody><tr><td>cd</td><td>ab</td><td>ef</td></tr><tr><td>ab</td><td>ef</td><td>cd</td></tr><tr><td>cd</td><td>ef</td><td>ab</td></tr><tr><td>ef</td><td>ab</td><td>cd</td></tr><tr><td>ef</td><td>cd</td><td>ab</td></tr></tbody></table><blockquote><p>每$A_3^3$种方案是1种，$C_6^2 C_4^2 C_2^2 \div A_3^3$。</p></blockquote><h3 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h3><p>1、9本书分堆，放书架</p><p>（1）9本书分成1，3，5三堆，然后放到3个不同的书架上，多少种放法？</p><p>（2）9本书平均分成3堆，然后放到3个不同的书架上，多少种方法?</p><p>（3）9本书分成2，2，5三堆，然后放到3个不同的的书架上，多少种方法?</p><p>2、把9个人分配到3个单位，有多少种分法?</p><p>1）甲单位2人，乙单位3人，丙单位4人</p><p>2）1个单位2人，一个单位3人，一个单位4人</p><p>3）每个单位3人</p><p>4）两个单位各2人，一个单位5人</p><p>3、把A，B,C,D四本不同的书分给三位同学，每人至少一本，每本书必须有人分到，A、B不能分给同一个人，多少种不同的分法?</p><hr><hr><p>解析分割线</p><hr><hr><h3 id="解析-5"><a href="#解析-5" class="headerlink" title="解析"></a>解析</h3><p>1、9本书分堆，放书架</p><p>（1）9本书分成1，3，5三堆，然后放到3个不同的书架上，多少种放法？</p><blockquote><ol><li>分组：$C_9^1 C_8^3 C_5^5$</li><li>放到书架：$A_3^3$</li></ol><p>故结果$C_9^1 C_8^3 C_5^5 A_3^3$。</p></blockquote><p>（2）9本书平均分成3堆，然后放到3个不同的书架上，多少种方法?</p><blockquote><ol><li>分组：$C_9^3 C_6^3 C_3^3 \div A_3^3$</li><li>放到书架：$A_3^3$</li></ol><p>故结果$C_9^3 C_6^3 C_3^3$。</p></blockquote><p>（3）9本书分成2，2，5三堆，然后放到3个不同的的书架上，多少种方法?</p><blockquote><ol><li>分组：$C_9^2 C_7^2 C_5^5 \div A_2^2$</li><li>放到书架：$A_3^3$</li></ol><p>故结果$C_9^2 C_7^2 C_5^5 \div A_2^2  \times A_3^3$。</p></blockquote><hr><p>2、把9个人分配到3个单位，有多少种分法?</p><p>1）甲单位2人，乙单位3人，丙单位4人</p><blockquote><ol><li>分组：$C_9^2 C_7^3 C_4^4$</li><li>分配到单位：已经指定单位，1种。</li></ol></blockquote><p>2）1个单位2人，一个单位3人，一个单位4人</p><blockquote><ol><li>分组：$C_9^2 C_7^3 C_4^4$</li><li>分配到单位：单位没指定，$A_3^3$</li></ol></blockquote><p>3）每个单位3人</p><blockquote><ol><li>分组：$C_9^3 C_6^3 C_3^3 \div A_3^3$</li><li>分配：$A_3^3$</li></ol></blockquote><p>4）两个单位各2人，一个单位5人</p><blockquote><ol><li>分组：$C_9^2 C_7^2 C_5^5 \div A_2^2$</li><li>分配：$A_3^3$</li></ol></blockquote><hr><p>3、把A，B，C，D四本不同的书分给三位同学，每人至少一本，每本书必须有人分到，A、B不能分给同一个人，多少种不同的分法?</p><blockquote><p>AB分给同一个的人分法只有1种，AB、C、D，在计算分组时，减去这一种分法。</p><p>$(\frac{C_4^1 C_3^1 C_2^2}{A_2^2} - 1) \times A_3^3$</p></blockquote><hr><p>参考视频</p><ul><li><p><a href="https://www.bilibili.com/video/BV1a7411N7gy?p=1&vd_source=49e30194f6d5798a1f90d69dad9c0460">1-排列组合计数原理基本定义_哔哩哔哩_bilibili</a></p><p>到</p></li><li><p><a href="https://www.bilibili.com/video/BV1a7411N7gy?p=9&vd_source=49e30194f6d5798a1f90d69dad9c0460">9-排列组合之易错易混淆_哔哩哔哩_bilibili</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 排列组合 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排列组合 </tag>
            
            <tag> CSP高频考点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-2022年CSP-J1链表合集</title>
      <link href="/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E9%93%BE%E8%A1%A8%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E9%93%BE%E8%A1%A8%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><h2 id="第-6-题"><a href="#第-6-题" class="headerlink" title="第 6 题"></a>第 6 题</h2><p>链表不具有的特点是（）</p><p>A. 插入删除不需要移动元素</p><p>B. 不必事先估计存储空间</p><p>C. 所需空间与线性表长度成正比</p><p>D. 可随机访问任一元素</p><blockquote><p>选D。解析：链表是一种常见的数据结构，它由一系列节点组成，每个节点包含两部分：数据域和指针域。数据域用于存储数据元素，而指针域用于存储下一个节点的地址。</p><p>选项A是正确的，因为链表的插入和删除操作只需要修改相邻节点的指针域，而不需要移动其他元素。这使得链表在插入和删除操作上比线性表更加高效。</p><p>选项B也是正确的，因为链表不必预先分配固定大小的存储空间。每当需要添加一个新元素时，只需分配一个新的节点，并将其添加到链表的末尾即可。这使得链表在内存使用上更加灵活。</p><p>选项C也是正确的，因为链表所需的存储空间与线性表的长度成正比。每个节点都需要额外的存储空间来存储指针域，而链表中的元素数量就是节点的数量。</p><p>然而，选项D是不正确的，因为链表不能随机访问任一元素。为了访问链表中的任一元素，必须从链表的头部开始遍历，直到找到目标元素或者到达链表的尾部。这种顺序访问的方式使得链表在随机访问上的性能较差于线性表。</p></blockquote><h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><h2 id="第-7-题"><a href="#第-7-题" class="headerlink" title="第 7 题"></a>第 7 题</h2><p>链表不具有的特点是（）。</p><p>A. 可随机访问任一元素</p><p>B. 不必事先估计存储空间</p><p>C. 插入删除不需要移动元素</p><p>D. 所需空间与线性表长度成正比</p><blockquote><p>选A. 可随机访问任一元素。</p><p>链表是一种线性数据结构，其中的元素不是连续存储的。每个元素都包含一个指向下一个元素的指针。因此，要访问链表中的任一元素，必须先遍历到该元素所在的节点，然后通过节点中的指针来访问该元素。由于需要遍历，所以链表不能像数组那样直接通过索引来访问任一元素，因此不具备随机访问任一元素的特点。</p></blockquote><h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><p>无。</p><hr><h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="第-4-题"><a href="#第-4-题" class="headerlink" title="第 4 题"></a>第 4 题</h2><p>链表和数组的区别包括（ ）。</p><p>A. 数组不能排序，链表可以</p><p>B. 链表比数组能存储更多的信息</p><p>C. 数组大小固定，链表大小可动态调整</p><p>D. 以上均正确</p><blockquote><p>选C。A错误，数组可以排序。B错误，没有上下文，不能确定。</p></blockquote><h2 id="第-11-题"><a href="#第-11-题" class="headerlink" title="第 11 题"></a>第 11 题</h2><p>以下哪组操作能完成在双向循环链表结点 p 之后插入结点 s 的效果（其中，next 域为结点的直接后继，prev 域为结点的直接前驱）：（ ）。</p><p>A. <code>p-&gt;next-&gt;prev=s; s-&gt;prev=p; p-&gt;next=s; s-&gt;next=p-&gt;next;</code></p><p>B. <code>P-&gt;next-&gt;prev=s; p-&gt;next=s; s-&gt;prev=p; s-&gt;next=p-&gt;next;</code></p><p>C. <code>s-&gt;prev=p; s-&gt;next=p-&gt;next; P-&gt;next=s; p-&gt;next-&gt;prev=s;</code></p><p>D. <code>s-&gt;next=p-&gt;next; p-&gt;next-&gt;prev=s; s-&gt;prev=p; p-&gt;next=s;</code></p><blockquote><p>选D。</p><ul><li><code>s-&gt;next = p-&gt;next;</code>在<code>p-&gt;next = s;</code> 前，否则就变成<code>s-&gt;next = s</code></li><li><code>p-&gt;next-&gt;prev = s;</code>在<code>p-&gt;next = s;</code>前，否则变成<code>s-&gt;prev = s</code></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 19-22年 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-2022年CSP-J1图合集</title>
      <link href="/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E5%9B%BE%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E5%9B%BE%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><p>无。</p><hr><h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><h2 id="第-8-题"><a href="#第-8-题" class="headerlink" title="第 8 题"></a>第 8 题</h2><p>有 10 个顶点的无向图至少应该有（ ）条边才能确保是一个连通图。</p><p>A. 9</p><p>B. 10</p><p>C. 11</p><p>D. 12</p><blockquote><p>选A。一个无向图的连通性是指图中任意两个顶点都存在一条路径相连。</p><p>对于有n个顶点的无向图，其连通性至少需要满足的条件是：当且仅当图中含有n-1条边时，这个图才是连通的。</p><p>因此，对于有10个顶点的无向图，至少需要9条边才能确保它是连通图。这是因为当图中只有8条边时，这个图就不是一个连通图。</p><p>举个例子，考虑一个有4个顶点的无向图，它只有3条边，所以它不是一个连通图。但是如果我们添加第4条边，这个图就变成了一个连通图。</p></blockquote><hr><h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><h2 id="第-6-题"><a href="#第-6-题" class="headerlink" title="第 6 题"></a>第 6 题</h2><p>对于有 n 个顶点、m 条边的无向连通图 (m&gt;n)，需要删掉（ ）条边才能使其成为一棵树。</p><p> A. n − 1</p><p>B. m − n</p><p>C. m − n − 1</p><p>D. m − n + 1</p><blockquote><p>选D。树有n - 1条边，把这个图变成树，即变成n - 1条边，需要删掉 <code>m - (n - 1) = m - n + 1</code> 条边。</p></blockquote><h2 id="第-14-题"><a href="#第-14-题" class="headerlink" title="第 14 题"></a>第 14 题</h2><p>以 <em>a</em> 为起点，对下边的无向图进行深度优先遍历，则 <em>b</em>,<em>c</em>,<em>d</em>,<em>e</em> 四个点中有可能作为最后一个遍历到的点的个数为（ ）。</p><p><img src="/../images/2019-2022%E5%B9%B4CSP-J1%E5%9B%BE%E5%90%88%E9%9B%86/image-20230827215903496.png" class="lazyload placeholder" data-srcset="/../images/2019-2022%E5%B9%B4CSP-J1%E5%9B%BE%E5%90%88%E9%9B%86/image-20230827215903496.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230827215903496"></p><p>A. 1</p><p>B. 2</p><p>C. 3</p><p>D. 4</p><blockquote><p>选B。b和e可能为最后一个点。</p></blockquote><hr><h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="第-9-题"><a href="#第-9-题" class="headerlink" title="第 9 题"></a>第 9 题</h2><p>考虑由 N 个顶点构成的有向连通图，采用邻接矩阵的数据结构表示时，该矩阵中至少存在（ ）个非零元素。</p><p>A. N − 1</p><p>B. N</p><p>C. <em>N</em>+1</p><p>D. $N^2$</p><blockquote><p>选B。边最少的情况，就是每个顶点只有一条入边和一条出边，连成一个圈，即连通图。</p></blockquote><h2 id="第-10-题"><a href="#第-10-题" class="headerlink" title="第 10 题"></a>第 10 题</h2><p>以下对数据结构的表述不恰当的一项为：（ ）。</p><p>A. 图的深度优先遍历算法常使用的数据结构为栈。</p><p>B. 栈的访问原则后进先出，队列的访问原则是先进先出。</p><p>C. 队列常常被用于广度优先搜索算法。</p><p>D. 栈与队列存在本质不同，无法用栈实现队列。</p><blockquote><p>选D。虽然本质不同，但是勉强能用，比较麻烦，用两个栈就能实现。</p><ul><li>入第1个栈，变成倒序。</li><li>入第2个栈，倒序反过来，就变回原来的顺序。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 19-22年 </tag>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-2022年CSP-J1栈合集</title>
      <link href="/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E6%A0%88%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E6%A0%88%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="2019"><a href="#2019" class="headerlink" title="2019"></a>2019</h1><p>无</p><h1 id="2020"><a href="#2020" class="headerlink" title="2020"></a>2020</h1><h2 id="第-11-题"><a href="#第-11-题" class="headerlink" title="第 11 题"></a>第 11 题</h2><p>下图中所使用的数据结构是（ )。</p><p><img src="/../images/2019-2022%E5%B9%B4CSP-J1%E6%A0%88%E5%90%88%E9%9B%86/image-20230827215440091.png" class="lazyload placeholder" data-srcset="/../images/2019-2022%E5%B9%B4CSP-J1%E6%A0%88%E5%90%88%E9%9B%86/image-20230827215440091.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230827215440091"></p><p>A. 栈</p><p>B. 队列</p><p>C. 二叉树</p><p>D. 哈希表</p><blockquote><p>选A。先入后出，是栈。</p></blockquote><h1 id="2021"><a href="#2021" class="headerlink" title="2021"></a>2021</h1><h2 id="第-5-题"><a href="#第-5-题" class="headerlink" title="第 5 题"></a>第 5 题</h2><p>对于入栈顺序为 a,b,c,d,e 的序列，下列（ ）不是合法的出栈序列。</p><p> A. a,b,c,d,e</p><p>B. e,d,c,b,a</p><p>C. b,a,c,d,e</p><p>D. c,d,a,e,b</p><blockquote><p>选D。</p></blockquote><div class="mermaid">flowchart LR AA(&quot;出栈顺序      ---​      栈&quot;) --&gt;       A(&quot;      ---​      c​        b        a&quot;) --&gt;|c出栈| B(&quot;c        ---​        b        a&quot;) --&gt;|d入栈| C(&quot;c        ---​        d​        b        a&quot;) --&gt;|d出栈| D(&quot;c d        ---​        b​        a&quot;) --&gt; |a出栈| E(a不在栈顶,错误)</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"> AA(&quot;出栈顺序</span><br><span class="line">      ---</span><br><span class="line">      栈&quot;) --&gt; </span><br><span class="line">      A(&quot;</span><br><span class="line">      ---</span><br><span class="line">      c</span><br><span class="line">        b</span><br><span class="line">        a&quot;) --&gt;|c出栈| B(&quot;c</span><br><span class="line">        ---</span><br><span class="line">        b</span><br><span class="line">        a&quot;) --&gt;|d入栈| C(&quot;c</span><br><span class="line">        ---</span><br><span class="line">        d</span><br><span class="line">        b</span><br><span class="line">        a&quot;) --&gt;|d出栈| D(&quot;c d</span><br><span class="line">        ---</span><br><span class="line">        b</span><br><span class="line">        a&quot;) --&gt; |a出栈| E(a不在栈顶,错误)</span><br></pre></td></tr></table></figure><h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><h2 id="第-2-题"><a href="#第-2-题" class="headerlink" title="第 2 题"></a>第 2 题</h2><p>有 6 个元素，按照 6、5、4、3、2、1 的顺序进入栈 S，请问下列哪个出栈序列是非法的（ ）。</p><p>A. 5 4 3 6 1 2</p><p>B. 4 5 3 1 2 6</p><p>C. 3 4 6 5 2 1</p><p>D. 2 3 4 1 5 6</p><blockquote><p>选C。</p></blockquote><div class="mermaid">graph LR     A(&quot;3456&quot;) --&gt;|弹出3| B(&quot;456&quot;) --&gt;|弹出4| C(&quot;56&quot;) --&gt;|弹出6| D[6出不来]style D fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">      A(&quot;3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6&quot;) --&gt;|弹出3| B(&quot;4</span><br><span class="line">5</span><br><span class="line">6&quot;) --&gt;|弹出4| C(&quot;5</span><br><span class="line">6&quot;) --&gt;|弹出6| D[6出不来]</span><br><span class="line"></span><br><span class="line"> style D fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5</span><br></pre></td></tr></table></figure><h2 id="第-5-题-1"><a href="#第-5-题-1" class="headerlink" title="第 5 题"></a>第 5 题</h2><p>对假设栈 S 和队列 Q 的初始状态为空。存在 e1~e6 六个互不相同的数据，每个数据按照进栈 S、出栈 S、进队列 Q、出队列 Q 的顺序操作，不同数据间的操作可能会交错。已知栈 S 中依次有数据 e1、e2、e3、e4、e5 和 e6 进栈，队列 Q 依次有数据 e2、e4、e3、e6、e5和 e1 出队列。则栈 S 的容量至少是（ ）个数据。</p><p>A. 2</p><p>B. 3</p><p>C. 4</p><p>D. 6</p><blockquote><p>选B。<strong>出队列</strong>的顺序跟<strong>进队列</strong>的顺序一样，跟第2题差不多，出队列Q的顺序看作<strong>出栈S</strong>的顺序即可。<br>栈容量最多为3。</p></blockquote><div class="mermaid">graph LR      A(&quot;e2e1&quot;) --&gt;|弹出e2| B(&quot;e4e3e1&quot;) --&gt;|弹出e4| C(&quot;e3e1&quot;) --&gt;|弹出e3, e5 e6进栈| D(&quot;e6e5e1&quot;) --&gt;|依次弹出e6 e5 e1| empty</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">      A(&quot;e2</span><br><span class="line">e1&quot;) --&gt;|弹出e2| B(&quot;e4</span><br><span class="line">e3</span><br><span class="line">e1&quot;) --&gt;|弹出e4| C(&quot;e3</span><br><span class="line">e1&quot;) --&gt;|弹出e3, e5 e6进栈| D(&quot;e6</span><br><span class="line">e5</span><br><span class="line">e1&quot;) --&gt;|依次弹出e6 e5 e1| empty</span><br></pre></td></tr></table></figure><h2 id="第-10-题"><a href="#第-10-题" class="headerlink" title="第 10 题"></a>第 10 题</h2><p>以下对数据结构的表述不恰当的一项为：（ ）。</p><p>A. 图的深度优先遍历算法常使用的数据结构为栈。</p><p>B. 栈的访问原则后进先出，队列的访问原则是先进先出。</p><p>C. 队列常常被用于广度优先搜索算法。</p><p>D. 栈与队列存在本质不同，无法用栈实现队列。</p><blockquote><p>选D。虽然本质不同，但是勉强能用，比较麻烦，用两个栈就能实现。</p><ul><li>入第1个栈，变成倒序。</li><li>入第2个栈，倒序反过来，就变回原来的顺序。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 19-22年 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-2022年CSP-J1二叉树合集</title>
      <link href="/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h1><h2 id="第-8-题"><a href="#第-8-题" class="headerlink" title="第 8 题"></a>第 8 题</h2><p>一棵二叉树如右图所示，若采用顺序存储结构，即用一维数组元素存储该二叉树中的结点（根结点的下标为 1，若某结点的下标为 <em>i</em>，则其左孩子位于下标 2<em>i</em> 处、右孩子位于下标2<em>i</em>+1 处），则该数组的最大下标至少为（）。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7d58dfs8.png?x-oss-process=image/resize,m_lfit,h_170,w_225" class="lazyload placeholder" data-srcset="https://cdn.luogu.com.cn/upload/image_hosting/7d58dfs8.png?x-oss-process=image/resize,m_lfit,h_170,w_225" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>A. 6</p><p>B. 10</p><p>C. 15</p><p>D. 12</p><blockquote><p>选C。 </p></blockquote><p><img src="/../images/2019-2022%E5%B9%B4CSP-J1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%88%E9%9B%86/image-20230815162747155.png" class="lazyload placeholder" data-srcset="/../images/2019-2022%E5%B9%B4CSP-J1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%88%E9%9B%86/image-20230815162747155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230815162747155"></p><h2 id="第-14-题"><a href="#第-14-题" class="headerlink" title="第 14 题"></a>第 14 题</h2><p>假设一棵二叉树的后序遍历序列为 DGJHEBIFCA，中序遍历序列为 DBGEHJACIF，则其前序遍历序列为（）。</p><p>A. ABCDEFGHIJ</p><p>B. ABDEGHJCFI</p><p>C. ABDEGJHCFI</p><p>D. ABDEGHJFIC</p><blockquote><p>选B。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A --&gt; B &amp; C</span><br><span class="line">    B --&gt; D &amp; E</span><br><span class="line">    E --&gt; G &amp; H</span><br><span class="line">    H --&gt; J</span><br><span class="line"></span><br><span class="line">    C --&gt; S((NULL)) &amp; F</span><br><span class="line">    F --&gt; I &amp; Q((NULL))</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="mermaid">graph TB​A --&gt; B &amp; C​B --&gt; D &amp; E​E --&gt; G &amp; H​H --&gt; J​C --&gt; S((NULL)) &amp; F​F --&gt; I &amp; Q((NULL))</div><h1 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h1><h2 id="第-12-题"><a href="#第-12-题" class="headerlink" title="第 12 题"></a>第 12 题</h2><p>独根树的高度为 1。具有 61 个结点的完全二叉树的高度为（ ）。</p><p>A. 7</p><p>B. 8</p><p>C. 5</p><p>D. 6</p><blockquote><p>选D。</p><p>解析：根据二叉树的性质，由于高度h的<strong>满二叉树</strong>共有$2^{h}-1$个结点，所以满二叉树的高度为 $\log_2(n+1)$，其中 n 为结点个数。</p><ul><li>高度h的<strong>完全二叉树</strong>至少有$2^{h-1}$个结点</li><li>高度h的<strong>完全二叉树</strong>至多有$2^h-1$个结点.</li></ul><p>因此，具有 61 个结点的完全二叉树的高度为 $\lfloor \log_2(61) \rfloor + 1 &#x3D; \lfloor \log_2(61) \rfloor + 1 &#x3D; 6$。</p></blockquote><blockquote><p>第1层有1个结点，第2层有2个结点，第3层有4个，每次都是乘2，从二进制数的角度看，就是左移一位。</p><p>第1层有1个结点，第2层有10个结点，第3层有100个。</p><p>高度为2的满二叉树共有 1 + 10 &#x3D; 11 个结点，高度为3的满二叉树共有 100 + 11 &#x3D; 111 个结点。</p></blockquote><h1 id="2021年"><a href="#2021年" class="headerlink" title="2021年"></a>2021年</h1><h2 id="第-8-题-1"><a href="#第-8-题-1" class="headerlink" title="第 8 题"></a>第 8 题</h2><p>如果一棵二叉树只有根结点，那么这棵二叉树高度为 1。请问高度为 5 的完全二叉树有 （ ）种不同的形态？</p><p>A. 16</p><p>B. 15</p><p>C. 17</p><p>D. 32</p><blockquote><p>A。高度为5，有<code>2^5 = 16</code>个节点，最后一层可以有0~16个节点，有16种形态。</p></blockquote><h1 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h1><h2 id="第-7-题"><a href="#第-7-题" class="headerlink" title="第 7 题"></a>第 7 题</h2><p>假设字母表 ｛a,b,c,d,e｝ 在字符串出现的频率分别为 10%，15%，30%，16%，29%。若使用哈夫曼编码方式对字母进行不定长的二进制编码，字母 d 的编码长度（ ）位。</p><p>A. 1</p><p>B. 2</p><p> C. 2 或 3</p><p>D. 3</p><blockquote><p>选B。构造哈夫曼树，每次选最小的两个数，合成一个新节点。</p><p><img src="/../images/2019-2022%E5%B9%B4CSP-J1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%88%E9%9B%86/image-20230819120436295.png" class="lazyload placeholder" data-srcset="/../images/2019-2022%E5%B9%B4CSP-J1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%90%88%E9%9B%86/image-20230819120436295.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819120436295"></p><p>到达d节点的路径为0 0，长度为2。</p></blockquote><h2 id="第-8-题-2"><a href="#第-8-题-2" class="headerlink" title="第 8 题"></a>第 8 题</h2><p>一棵有 n 个结点的完全二叉树用数组进行存储与表示，已知根结点存储在数组的第 1 个位置。若存储在数组第 9 个位置的结点存在兄弟结点和两个子结点，则它的兄弟结点和右子结点的位置分别是（ ）。</p><p>A. 8、18</p><p>B. 10、18</p><p>C. 8、19</p><p>D. 10、19</p><blockquote><p>选C。</p><ul><li>9是奇数，是右子节点，兄弟节点在左边。</li><li>左子<code>2 * x</code>，右子<code>2 * x + 1</code>，9的右子节点位置为<code>2 * 9 + 1 = 19</code>。</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 19-22年 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-2022年CSP-J1排列组合合集</title>
      <link href="/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%90%88%E9%9B%86/"/>
      <url>/2023/08/27/2019-2022%E5%B9%B4CSP-J1%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h1><h2 id="第-7-题"><a href="#第-7-题" class="headerlink" title="第 7 题"></a>第 7 题</h2><p>把 8 个同样的球放在 5 个同样的袋子里，允许有的袋子空着不放，问共有多少种不同的分法？（）</p><p>提示：如果 8 个球都放在一个袋子里，无论是哪个袋子，都只算同一种分法。</p><p>A. 22</p><p>B. 24</p><p>C. 18</p><p>D. 20</p><blockquote><p>选C。</p><p>4个空袋：1种</p><p>3个空袋：1+7，2+6，3+5，4+4</p><p>2个空袋：1+1+6，1+2+5，1+3+4，2+2+4，2+3+3</p><p>1个空袋：1+1+1+5，1+1+2+4，1+1+3+3，1+2+2+3，2+2+2+2</p><p>没有空袋：1+1+1+1+4，1+1+1+2+3，1+1+2+2+2</p></blockquote><h2 id="第-12-题"><a href="#第-12-题" class="headerlink" title="第 12 题"></a>第 12 题</h2><p>—副纸牌除掉大小王有 52张牌，四种花色，每种花色 13 张。</p><p>假设从这 52 张牌中随机抽取 13 张纸牌，则至少（）张牌的花色一致。</p><p>A. 4</p><p>B. 2</p><p>C. 3</p><p>D. 5</p><blockquote><p>选A。解析：这是一个应用鸽巢原理的问题。鸽巢原理，又称抽屉原理，是组合数学中的一个定理。其基本内容是：如果把$n+1$个物体放入$n$个盒子，那么至少有一个盒子里有两个物体。</p><p>在这个问题中，”鸽子”是52张牌，”鸽巢”是4种花色。我们需要从52张牌中抽取13张牌，那么根据鸽巢原理，至少有一个花色的牌数大于等于$\dfrac{13}{4}&#x3D;3.25$,向上取整得4。</p><p>所以至少4张牌的花色一致。</p></blockquote><h2 id="第-13-题"><a href="#第-13-题" class="headerlink" title="第 13 题"></a>第 13 题</h2><p>—些数字可以颠倒过来看，例如 0,1,8 颠倒过来还是本身，6 颠倒过来是 9，9 颠倒过来看还是 6，其他数字颠倒过来都不构成数字。<br>类似的，一些多位数也可以颠倒过来看，比如 106 颠倒过来是 901。假设某个城市的车牌只由 5 位数字组成，每一位都可以取 0 到 9。<br>请问这个城市最多有多少个车牌倒过来恰好还是原来的车牌？（）</p><p>A. 60</p><p>B. 125</p><p>C. 75</p><p>D. 100</p><blockquote><p>选C。第1、2位有（0、1、8、6、9）五个数字，第3位有（0、1、8）三个数字，第4、5位由第1、2位决定(如第1位6，则第5位9）。<code>5 * 5 * 3 = 75</code></p></blockquote><hr><h1 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h1><h2 id="第-10-题"><a href="#第-10-题" class="headerlink" title="第 10 题"></a>第 10 题</h2><p>5 个小朋友并排站成一列，其中有两个小朋友是双胞胎，如果要求这两个双胞胎必须相邻，则有（ ）种不同排列方法?</p><p>A. 48</p><p>B. 36</p><p>C. 24</p><p>D. 72</p><blockquote><p>选A。我们可以把双胞胎看作一个整体，那么就有4个整体(3个小朋友和一个双胞胎整体)需要排列，共有$4!&#x3D;24$种排列方法。而双胞胎之间又有2种排列方法。所以总的排列方法为$24\times2$ $&#x3D;48$种。</p></blockquote><h2 id="第-14-题"><a href="#第-14-题" class="headerlink" title="第 14 题"></a>第 14 题</h2><p>10 个三好学生名额分配到 7 个班级，每个班级至少有一个名额，一共有（ ）种不同的分配方案。</p><p>A. 84</p><p>B. 72</p><p>C. 56</p><p>D. 504</p><blockquote><p>选A。可将10个学生看成10个元素，一字排开，元素之间形成9个空。在9个空中插入6块板即可将其分为7部分，则共有$C_9^6&#x3D;84$种方案。</p></blockquote><h2 id="第-15-题"><a href="#第-15-题" class="headerlink" title="第 15 题"></a>第 15 题</h2><p>有五副不同颜色的手套（共 10 只手套，每副手套左右手各 1 只），一次性从中取 6 只手套，请问恰好能配成两副手套的不同取法有（ ）种。</p><p>A. 120</p><p>B. 180</p><p>C. 150</p><p>D. 30</p><blockquote><p>选A。恰好能配成两幅手套，那么只能是$5$只手套成一副，剩下1只手套。</p><p>所以先从5副中取2副，有$C_5^2&#x3D;10$种，</p><p>再从剩下的6只中，取第5个，6种取法，</p><p>从剩下的5只中，取第6个，不能与第5个相同，只有2种取法，</p><p>共有$C_5^2\times 6 \times \times 2&#x3D;120$种。</p></blockquote><hr><h1 id="2021年"><a href="#2021年" class="headerlink" title="2021年"></a>2021年</h1><h2 id="第-10-题-1"><a href="#第-10-题-1" class="headerlink" title="第 10 题"></a>第 10 题</h2><p>6 个人，两个人组一队，总共组成三队，不区分队伍的编号。不同的组队情况有（ ）种。</p><p>A. 10</p><p>B. 15</p><p>C. 30</p><p>D. 20</p><blockquote><p>选B。6取2，剩下4取2，剩下2取2，队伍没有顺序，要除以三个队伍的排列数。$C_6^2 * C^2_4 * C^2_2 &#x2F; A_3^3 &#x3D; 15$</p></blockquote><h2 id="第-12-题-1"><a href="#第-12-题-1" class="headerlink" title="第 12 题"></a>第 12 题</h2><p>由 1,1,2,2,3 这五个数字组成不同的三位数有（ ）种。</p><p>A. 18 </p><p>B. 15</p><p>C. 12</p><p>D. 24</p><blockquote><p>选A。依次枚举：</p><p>1开头：112、113、121、122、123、131、132</p><p>2开头：211、212、213、221、223、231、232</p><p>3开头：311、312、321、322</p></blockquote><hr><h1 id="2022年"><a href="#2022年" class="headerlink" title="2022年"></a>2022年</h1><p>无。</p><hr>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 19-22年 </tag>
            
            <tag> 排列组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入之类型及提交方式</title>
      <link href="/2023/08/24/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/"/>
      <url>/2023/08/24/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>简单的SQL注入都是用<code>id = -1</code>，用了数字，但是MySQL有字符类型，注入方式就不同了，这篇文章来分一下类型以及注入方式。</p></blockquote><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="参数类型"><a href="#参数类型" class="headerlink" title="参数类型"></a>参数类型</h3><ul><li>数字：<code>select * from user where id = 1;</code> ，<code>1</code>是数字。</li><li>字符：<code>select * from user where name = &#39;SleepWalker&#39;;</code>，<code>SleepWalker</code>是字符，要用<strong>引号</strong>括起来，不然会报错。</li><li>搜索（like）：<code>select * from user where name like &#39;%SleepWalker%&#39;;</code>，用<code>like</code>搜索，<code>%</code>是通配符。</li></ul><p>看一下字符的代码案例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;x&#x27;</span>];</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;select * from user where name = &#x27;<span class="subst">$name</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure><p>这时注入<code>?x=SleepWalker and 1 = 1</code>，最终SQL语句会拼接成<code>select * from user where name = &#39;SleepWalker and 1 = 1&#39;</code>，此时的<code>1 = 1</code>不是条件了，而是字符串的一部分，于是注入失败。</p><h3 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h3><ul><li>GET、POST、COOKIE、REQUEST、HTTP头</li></ul><p>用下面的代码测试请求</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"></span><br><span class="line"><span class="variable">$get</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;g&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;GET：&#x27;</span>.<span class="variable">$get</span>.<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$p</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;p&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;POST：&#x27;</span>.<span class="variable">$p</span>.<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$c</span> = <span class="variable">$_COOKIE</span>[<span class="string">&#x27;c&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;COOKIE：&#x27;</span>.<span class="variable">$c</span>.<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$r</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;r&#x27;</span>]; <span class="comment">//GET和POST请求都接收</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;REQUEST：&#x27;</span>.<span class="variable">$r</span>.<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$s</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;SERVER_NAME&#x27;</span>]; <span class="comment">//服务器和执行环境信息</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;SERVER：&#x27;</span>.<span class="variable">$s</span>.<span class="string">&#x27;&lt;br/&gt;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p><code>$_SERVER</code>详情看这里<a href="https://www.php.net/manual/zh/reserved.variables.server.php">PHP: $_SERVER - Manual</a></p><ul><li>其他SQL语句干扰符号<ul><li><code>&#39; &quot; % ) &#125;</code>等</li></ul></li></ul><h3 id="靶场练习"><a href="#靶场练习" class="headerlink" title="靶场练习"></a>靶场练习</h3><p>在靶场中练习明确<strong>参数类型</strong>。</p><h4 id="sqli-labs第5关"><a href="#sqli-labs第5关" class="headerlink" title="sqli-labs第5关"></a>sqli-labs第5关</h4><ol><li>首先用<code>and 1=1</code>和<code>and 1=2</code>判断参数<code>id</code>是否数字。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8085/sqli-labs/Less-5/?id=1 and 1=1</span><br><span class="line">http://localhost:8085/sqli-labs/Less-5/?id=1 and 1=2</span><br><span class="line"></span><br><span class="line">页面都正常，参数不是数字。</span><br></pre></td></tr></table></figure><ol start="2"><li>判断参数<code>id</code>是否字符：加单引号，后面注释掉。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8085/sqli-labs/Less-5/?id=1&#x27; and 1=1--+//页面正常</span><br></pre></td></tr></table></figure><p><img src="/../images/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/image-20230824182010520.png" class="lazyload placeholder" data-srcset="/../images/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/image-20230824182010520.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1=1"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8085/sqli-labs/Less-5/?id=1&#x27; and 1=2--+//页面错误</span><br></pre></td></tr></table></figure><p><img src="/../images/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/image-20230824182031442.png" class="lazyload placeholder" data-srcset="/../images/SQL%E6%B3%A8%E5%85%A5%E4%B9%8B%E7%B1%BB%E5%9E%8B%E5%8F%8A%E6%8F%90%E4%BA%A4%E6%96%B9%E5%BC%8F/image-20230824182031442.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="1=2"></p><p>存在注入点，得出参数是<strong>字符</strong>。（如果单引号不行，继续尝试双引号）</p><hr><p>参考视频</p><ul><li><a href="https://www.bilibili.com/video/BV1JZ4y1c7ro/?p=13&spm_id_from=pageDriver&vd_source=49e30194f6d5798a1f90d69dad9c0460">第14天：WEB漏洞-SQL注入之类型及提交注入_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 渗透测试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019-2023 CSP-J1 考点统计</title>
      <link href="/2023/08/21/%E8%80%83%E7%82%B9%E7%BB%9F%E8%AE%A1/"/>
      <url>/2023/08/21/%E8%80%83%E7%82%B9%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<div class="mermaid">pie    title CSP-J1选择题考点统计    &quot;链表&quot; : 5    &quot;栈&quot; : 5    &quot;树&quot; : 8    &quot;图&quot; : 6    &quot;排列组合&quot; : 9​&quot;进制转换&quot; : 5</div><table><thead><tr><th>题号</th><th>2023CSP-J1</th><th><strong>2022CSP-J1</strong></th><th><strong>2021CSP-J1</strong></th><th><strong>2020CSP-J1</strong></th><th align="left"><strong>2019CSP-J1</strong></th></tr></thead><tbody><tr><td><strong>一、单项选择题</strong></td><td></td><td></td><td></td><td></td><td align="left"></td></tr><tr><td>1</td><td>C++关键字const</td><td>面向对象概念</td><td>面向对象概念</td><td>内存地址</td><td align="left">顶级域名</td></tr><tr><td>2</td><td>相同进制数相加</td><td>出入栈顺序</td><td>计算机相关奖项</td><td>编译器概念</td><td align="left">位运算（与）</td></tr><tr><td>3</td><td>union，结构体运算符</td><td>指针</td><td>二进制存储</td><td>逻辑运算</td><td align="left">int占用字节</td></tr><tr><td>4</td><td>链表，插入结点到头部</td><td>链表和数组的概念</td><td>时间复杂度</td><td>根据像素求图片大小、单位转换，bit、Byte、MB</td><td align="left">for循环</td></tr><tr><td>5</td><td>三叉树高度</td><td>出入栈顺序、出入队列顺序</td><td>出入栈顺序</td><td>冒泡排序</td><td align="left">二分查找，时间复杂度分析</td></tr><tr><td>6</td><td>排列组合</td><td>前缀表达式</td><td>无向连通图</td><td>递归</td><td align="left">链表特点</td></tr><tr><td>7</td><td>高精度概念</td><td>哈夫曼编码</td><td>进制转换 2 –&gt; 10</td><td>链表概念</td><td align="left">排列组合</td></tr><tr><td>8</td><td>后缀转中缀</td><td>完全二叉树</td><td>完全二叉树</td><td>无向连通图</td><td align="left">二叉树，一维数组存储，求下标</td></tr><tr><td>9</td><td>不同进制数相加</td><td>有向图</td><td>后缀表达式</td><td>进制转换 2 –&gt; 10</td><td align="left">素数</td></tr><tr><td>10</td><td>哈夫曼编码</td><td>图、栈、队列概念</td><td>排列组合</td><td>排列组合</td><td align="left">最大公约数</td></tr><tr><td>11</td><td>二叉树，根据两种遍历数列求遍历另一种序列</td><td>双向循环链表</td><td>哈夫曼编码概念</td><td>栈</td><td align="left">模拟</td></tr><tr><td>12</td><td>图：拓扑排序</td><td>排序算法稳定性</td><td>排列组合，枚举</td><td>完全二叉树的高度</td><td align="left">排列组合</td></tr><tr><td>13</td><td>数据存储容量</td><td>进制转换 8-&gt;10</td><td>递归</td><td>取余运算</td><td align="left">排列足额和</td></tr><tr><td>14</td><td>排列组合</td><td>字符串的子串</td><td>图的深度优先遍历</td><td>排列组合</td><td align="left">二叉树，根据两种遍历数列求遍历另一种序列</td></tr><tr><td>15</td><td>操作系统概念</td><td>递归概念</td><td>小船过河</td><td>排列组合</td><td align="left">计算机领域奖项</td></tr><tr><td>———</td><td></td><td></td><td></td><td></td><td align="left"></td></tr><tr><td><strong>二、阅读程序</strong></td><td></td><td></td><td></td><td></td><td align="left"></td></tr><tr><td>2.1</td><td>求三角形面积的海伦公式</td><td>位运算</td><td>补码，位运算</td><td>字符串、编解码</td><td align="left">字符串，小写转大写字母</td></tr><tr><td>2.2</td><td>最长公共子序列</td><td>递推、动态规划</td><td>字符串编码，asc码，位运算</td><td>进制转换</td><td align="left">匹配</td></tr><tr><td>2.3</td><td>因数</td><td>二分答案、牛顿迭代法求根号</td><td>线性筛质数</td><td>DFS</td><td align="left">根据两数组构造二叉树</td></tr><tr><td>———</td><td></td><td></td><td></td><td></td><td align="left"></td></tr><tr><td><strong>三、完善程序</strong></td><td></td><td></td><td></td><td></td><td align="left"></td></tr><tr><td>3.1</td><td>二分查找缺失的数据</td><td>枚举因数</td><td>Josephus 问题，递归</td><td>质因数分解</td><td align="left">矩阵变换</td></tr><tr><td>3.2</td><td>动态规划：编辑距离</td><td>宽搜（洪泛法）</td><td>二分查找，冒泡排序</td><td>贪心法</td><td align="left">计数排序</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 考点统计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第2章 应用层</title>
      <link href="/2023/08/16/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>/2023/08/16/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<blockquote><p>In Process</p></blockquote><p>创建一个新的网络应用 </p><p>编程</p><ul><li>在不同的端系统上运行 </li><li>通过网络基础设施提供的服务，应用进程彼此通信 </li><li>如Web: <ul><li>Web 服务器软件与浏览器软件通信</li></ul></li></ul><p><strong>网络核心中没有应用层软件</strong> </p><ul><li>网络核心没有应用层功能 </li><li>网络应用只在端系统上存在 ，快速网络应用开发和部署</li></ul><h1 id="2-1-应用层协议原理"><a href="#2-1-应用层协议原理" class="headerlink" title="2.1 应用层协议原理"></a>2.1 应用层协议原理</h1><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><p>客户-服务器（C&#x2F;S）</p><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230816210655249.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230816210655249.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="C/S"></p><ul><li>服务器: <ul><li>一直运行 </li><li>固定的IP地址和周知的端口号（约定） </li><li>扩展性：服务器场 <ul><li>数据中心进行扩展 </li><li>扩展性差</li></ul></li></ul></li><li>客户端: <ul><li>主动与服务器通信 </li><li>与互联网有间歇性的连接 </li><li>可能是动态IP地址 </li><li>不直接与其它客户端通信</li></ul></li></ul><p>对等体（P2P）</p><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230816210815378.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230816210815378.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="P2P"></p><ul><li>（几乎）没有一直运行的服务器 </li><li>任意端系统之间可以进行通信 </li><li>每一个节点既是客户端又是服务器<ul><li><strong>自扩展性</strong>：新peer节点带来新的服务能力，当然也带来新的服务请求</li></ul></li><li>参与的主机间歇性连接且可以 改变IP 地址 <ul><li><strong>难以管理</strong></li></ul></li><li>例子: Gnutella，迅雷</li></ul><p>C&#x2F;S和P2P体系结构的混合体</p><p>Napster </p><ul><li>文件搜索：集中 <ul><li>主机在中心服务器上注册其资源 </li><li>主机向中心服务器查询资源位置</li></ul></li><li>文件传输：P2P <ul><li>任意Peer节点之间</li></ul></li></ul><p>即时通信 </p><ul><li>在线检测：集中 <ul><li>当用户上线时，向中心服务器注册其IP地址 </li><li>用户与中心服务器联系，以找到其在线好友的位置</li></ul></li><li>两个用户之间聊天：P2P</li></ul><p>进程通信</p><p>进程：在主机上运行的应用程序 </p><ul><li><p>在同一个主机内，使用<strong>进程间通信机制</strong>通信（ 操作系统定义） </p></li><li><p>不同主机，通过交换<strong>报文</strong>（Message）来通信 </p><ul><li>使用OS提供的通信服务 </li><li>按照应用协议交换报文 <ul><li>借助传输层提供的服务</li></ul></li></ul></li><li><p>注意：P2P架构的应用也 有客户端进程和服务器进 程之分</p></li></ul><h2 id="需要解决的问题"><a href="#需要解决的问题" class="headerlink" title="需要解决的问题"></a>需要解决的问题</h2><h3 id="问题1：对进程进行编址（addressing）"><a href="#问题1：对进程进行编址（addressing）" class="headerlink" title="问题1：对进程进行编址（addressing）"></a>问题1：对进程进行编址（addressing）</h3><ul><li>进程为了接收报文，必须有一个标识 即：SAP（发送也需要标示） <ul><li>主机：唯一的 32位<strong>IP地址</strong> <ul><li>仅仅有IP地址不能够唯一标示一个进程；在一台端系统上有很 多应用进程在运行</li></ul></li><li>所采用的传输层协议：TCP or UDP </li><li><strong>端口号</strong>（Port Numbers）</li></ul></li><li>一些知名端口号的例子： <ul><li>HTTP: TCP 80 Mail: TCP25 ftp:TCP 2</li></ul></li><li>一个进程：用 IP+port 标示 端节点 </li><li>本质上，一对主机进程之间的通信由2个端节点构 成</li></ul><h3 id="问题2：传输层提供的服务"><a href="#问题2：传输层提供的服务" class="headerlink" title="问题2：传输层提供的服务"></a>问题2：传输层提供的服务</h3><p>需要穿过层间的信息  </p><ul><li>层间接口必须要携带的信息 <ul><li>要传输的报文（对于本层来说：SDU） </li><li>谁传的：对方的应用进程的标示：IP+TCP(UDP) 端口 </li><li>传给谁：对方的应用进程的标示：对方的IP+TCP(UDP)端口号</li></ul></li><li>传输层实体（tcp或者udp实体）根据这些信息进行TCP 报文段（UDP数据报）的封装 <ul><li>源端口号，目标端口号，数据等 </li><li>将IP地址往下交IP实体，用于封装IP数据报：源IP,目标IP</li></ul></li></ul><p>层间信息的代表</p><ul><li>如果Socket API 每次传输报文，都携带如此多 的信息，太繁琐易错，不便于管理 </li><li>用个代号标示通信的双方或者单方：socket </li><li>就像OS打开文件返回的句柄一样 <ul><li>对句柄的操作，就是对文件的操作</li></ul></li><li>TCP socket： <ul><li>TCP服务，两个进程之间的通信需要之前要建立连接 <ul><li>两个进程通信会<strong>持续</strong>一段时间，通信关系稳定</li></ul></li><li>可以用一个整数表示两个应用实体之间的通信关系 ，<strong>本地</strong>标示 </li><li>穿过层间接口的信息量<strong>最小</strong> </li><li>TCP socket：源IP，源端口，目标IP，目标IP,目标 端口</li></ul></li></ul><p>TCP之上的套接字（socket） </p><ul><li>对于使用面向连接服务（TCP）的应用而言，套接字是4元组的一个具有<strong>本地意义的标示</strong> <ul><li>4元组：(<strong>源IP，源port，目标IP，目标port</strong>) </li><li>唯一的指定了一个会话（2个进程之间的会话关系） </li><li>应用使用这个<strong>标示</strong>，与远程的应用进程通信 </li><li>不必在每一个报文的发送都要指定这4元组  就像使用操作系统打开一个文件，OS返回一个文件句 柄一样，以后使用这个文件句柄，而不是使用这个文件 的目录名、文件名 </li><li>简单，便于管理</li></ul></li></ul><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230821123908882.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230821123908882.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230821123908882"></p><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230821115459196.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230821115459196.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="传输过程"></p><p>除了TCP，还有UDP</p><p>UDP socket： </p><ul><li>UDP服务，两个进程之间的通信需要之前无需建立连接 <ul><li>每个报文都是独立传输的 </li><li>前后报文可能给不同的分布式进程</li></ul></li><li>因此，只能用一个整数表示本应用实体的标示 <ul><li>因为这个报文可能传给另外一个分布式进程 ·1</li></ul></li><li>穿过层间接口的信息大小最小 </li><li>UDP socket：本IP,本端口</li><li>但是传输 报文时：必须要提供对方IP，port <ul><li>接收报文时： 传输层需要上传对方的IP，port</li></ul></li></ul><p>UDP之上的套接字（socket） </p><ul><li>对于使用无连接服务（UDP）的应用而言，套接字是2元组的一个具有<strong>本地意义的标示</strong> <ul><li>2元组：<strong>IP，port</strong> （源端指定） </li><li>UDP套接字指定了应用所在的一个<strong>端节点</strong>（end  point） </li><li>在发送数据报时，采用创建好的本地套接字（标示 ID），就不必在发送每个报文中指明自己所采用的 ip和port </li><li>但是在发送报文时，必须要指定对方的ip和udp  port(另外一个段节点)</li></ul></li></ul><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230821124042283.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230821124042283.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230821124042283"></p><h3 id="问题3：如何使用传输层提供的服务实现应用"><a href="#问题3：如何使用传输层提供的服务实现应用" class="headerlink" title="问题3：如何使用传输层提供的服务实现应用"></a>问题3：如何使用传输层提供的服务实现应用</h3><ol><li>定义应用层协议：报文格式，解释，时序等。</li><li>编制程序，通过API调用网络基础设施提供通信 服务传报文，解析报文，实现应用时序等。</li></ol><p>应用层协议是什么？</p><ul><li>定义了：运行在不同端系统上的应用进程如何相互交换报文 <ul><li>交换的<strong>报文类型</strong>：请求和应答报文</li><li>各种报文类型的<strong>语法</strong>：报文中的 各个字段及其描述 </li><li>字段的<strong>语义</strong>：即字段取值的含义 </li><li><strong>同步</strong>，进程何时、如何发送报文及对报 文进行响应的规则</li></ul></li><li>应用协议仅仅是应用的一个组 成部分 <ul><li>Web应用：HTTP协议，web客 户端，web服务器，HTML</li></ul></li></ul><p>公开协议： </p><ul><li>由RFC文档定义 </li><li>允许互操作 </li><li>如HTTP, SMTP</li></ul><p>专用（私有）协议： </p><ul><li>协议不公开 </li><li>如：Skype</li></ul><p>应用需要传输层提供什么样的服务？如何描述传输层的服务？</p><p> <strong>数据丢失率</strong> </p><ul><li>有些应用则要求100%的可 靠数据传输（如文件） </li><li>有些应用（如音频）能容忍 一定比例以下的数据丢失</li></ul><p><strong>延迟</strong> </p><ul><li>一些应用 出于有效性考虑，对数据传输有严格的时间限制 <ul><li>Internet 电话、交互式游戏 </li><li>延迟、延迟差</li></ul></li></ul><p><strong>吞吐</strong> </p><ul><li>一些应用（如多媒体）必须 需要最小限度的吞吐，从而使得应用能够有效运转 </li><li>一些应用能充分利用可供使用的吞吐(弹性应用)</li></ul><p><strong>安全性</strong> </p><ul><li>机密性 </li><li>完整性 </li><li>可认证性（鉴别）</li></ul><p>Internet 传输层提供的服务</p><p>TCP 服务：</p><ul><li><strong>可靠</strong>的传输服务</li><li><strong>流量控制</strong>：发送方不会淹没接受方</li><li><strong>拥塞控制</strong>：当网络出现拥塞时，能抑制发送方</li><li><strong>不能提供的服务</strong>：时间保证、最小吞吐保证和安全</li><li><strong>面向连接</strong>：要求在客户端进程和服务器进程之间建立连接</li></ul><p>UDP 服务：</p><ul><li><strong>不可靠</strong>数据传输</li><li>不提供的服务：可靠，流量控制、拥塞控制、时间、带宽保证、建立连接</li></ul><p>虽然UDP不可靠，但还是有应用场景的，以下是UDP存在的必要性：</p><ul><li>能够<strong>区分不同的进程</strong>，而IP服务不能 <ul><li>在IP提供的主机到主机端到端功能的基础上，区分了主机的应用进程</li></ul></li><li><strong>无需建立连接</strong>，省去了建立连接时间，适合事务性的应用</li><li><strong>不做可靠性的工作</strong>，例如检错重发，适合那些对实时性要求比较高而对正确性要求不高的应用 <ul><li>因为为了实现可靠性（准确性、保序等），必须付出时间代<br>价（检错重发）</li></ul></li><li>没有拥塞控制和流量控制，应用能够<strong>按照设定的速度发送数据</strong> <ul><li>而在TCP上面的应用，应用发送数据的速度和主机向网络发送的实际速度是不一致的，因为有流量控制和拥塞控制</li></ul></li></ul><p>安全TCP </p><p>TCP &amp; UDP  </p><ul><li>都没有加密 </li><li>明文通过互联网传输 ，甚至密码</li></ul><p>SSL </p><ul><li>在TCP上面实现，提供加密的TCP连接 </li><li>私密性 </li><li>数据完整性 </li><li>端到端的鉴别</li></ul><p>SSL在应用层</p><ul><li>应用采用SSL库，SSL库使用TCP通信</li></ul><p>SSL socket API</p><ul><li>应用通过API将明文交给socket，SSL将其加密在互联网上传输</li></ul><hr><h1 id="2-2-Web-and-HTTP"><a href="#2-2-Web-and-HTTP" class="headerlink" title="2.2 Web and HTTP"></a>2.2 Web and HTTP</h1><p>一些术语 </p><ul><li><strong>Web页</strong>：由一些<strong>对象</strong>组成 </li><li>对象可以是HTML文件、JPEG图像、Java小程序、声 音剪辑文件等 </li><li>Web页含有一个<strong>基本的HTML文件</strong>，该基本HTML文 件又包含若干对象的引用（链接） </li><li>通过<strong>URL</strong>对每个对象进行引用 <ul><li>访问协议，用户名，口令字，端口等；</li></ul></li><li>URL格式<ul><li>Prot:&#x2F;&#x2F;user:<a href="mailto:&#112;&#x73;&#x77;&#x40;&#119;&#x77;&#x77;&#x2e;&#115;&#x6f;&#x6d;&#x65;&#x53;&#99;&#x68;&#111;&#111;&#108;&#46;&#x65;&#100;&#117;">&#112;&#x73;&#x77;&#x40;&#119;&#x77;&#x77;&#x2e;&#115;&#x6f;&#x6d;&#x65;&#x53;&#99;&#x68;&#111;&#111;&#108;&#46;&#x65;&#100;&#117;</a>:portsomeDept&#x2F;pic.gif</li></ul></li></ul><table><thead><tr><th>协议名</th><th>用户：口令</th><th>主机名</th><th>端口</th><th>路径名</th></tr></thead><tbody><tr><td>Prot:&#x2F;&#x2F;</td><td>user:psw@</td><td><a href="http://www.someschool.edu/">www.someSchool.edu</a></td><td>:prot</td><td>&#x2F;someDept.gif</td></tr></tbody></table><h2 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h2><p><strong>HTTP</strong>: 超文本传输协议，是Web的<strong>应用层</strong>协议，使用<strong>客户&#x2F;服务器</strong>模式 </p><ul><li>客户: 请求、接收和显示 Web对象的浏览器 </li><li>服务器: 对请求进行响应， 发送对象的Web服务器</li></ul><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230822162753363.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230822162753363.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="发送请求"></p><p>电脑或手机上的浏览器就是客户端，客户端向Web服务器<strong>发送请求</strong>，服务器接收到请求，返回<strong>响应</strong>给客户端，浏览器根据响应的html来画出页面，此时电脑或手机就能看到网页了。</p><p>不过，在发送请求前，HTTP需要建立<strong>TCP</strong>连接</p><ol><li>客户发起一个与服务器的<strong>TCP</strong>连接 (建立套接字) ，端口号为 <strong>80</strong></li><li>服务器接受客户的TCP连接</li><li>在浏览器(HTTP客户端)与 Web服务器(HTTP服务器 server)交换HTTP报文 (应用层协议报文) </li><li>TCP连接关闭</li></ol><p>同时，HTTP是<strong>无状态</strong>的，服务器并不维护关于客户的任何信息。</p><p>而且，维护状态的协议很复杂！</p><ol><li>必须维护历史信息(状态)</li><li>如果服务器&#x2F;客户端死机，它们的状态信息可能不一致，二者的信息必须是一致</li><li>无状态的服务器能够支持更多的客户端</li></ol><p>HTTP有两个版本，HTTP1.0和HTTP1.1，1.0是非持久HTTP，1.1是持久HTTP，有下列区别：</p><table><thead><tr><th>非持久HTTP（HTTP&#x2F;1.0）</th><th>持久HTTP（HTTP&#x2F;1.1）</th></tr></thead><tbody><tr><td>最多只有一个对象在 TCP连接上发送<br/>下载多个对象需要多 个TCP连接</td><td>多个对象可以在一个 （在客户端和服务器之间的）TCP连接上传输</td></tr><tr><td>请求后<strong>关闭TCP连接</strong>，下一次请求重新建立TCP连接</td><td>建立TCP连接后，会<strong>保持一段时间</strong>,下一次请求<strong>不需要</strong>重新建立TCP连接</td></tr></tbody></table><p>客户端发送请求 和 接收服务器的响应 都需要时间，这个时间叫做<strong>往返时间RTT</strong>（round-trip time），即一个小的<strong>分组</strong>从客户端到服务器，在回到客户端的时间（传输时间忽略）。</p><p>客户端发送请求 和 接收服务器的响应 的时间：2RTT + 传输时间。</p><ol><li>一个RTT用来发起TCP连接</li><li>一个 RTT用来HTTP请求并等待HTTP响应</li><li>文件传输时间</li></ol><h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>下面我们来看一下HTTP报文，分为两种类：<strong>请求、响应</strong>。</p><p>先来看HTTP请求报文</p><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230823110040960.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230823110040960.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230823110040960"></p><p>网页通常包括表单输入，提交表单的方式有两种：</p><ol><li>POST方式<ul><li>包含在实体主体 (entity body )中的 输入被提交到服务器</li></ul></li><li>URL方式<ul><li>方法：GET </li><li>输入通过请求行的 URL字段上载</li></ul></li></ol><p>B站视频的URL，<code>https://www.bilibili.com/video/BV1JV411t7ow/?p=14&amp;spm_id_from=pageDrive</code>，后面这一段<code>?p=14&amp;spm_id_from=pageDrive</code>就是参数，使用了URL方式输入。</p><p>除了这两种请求方式，还有其他请求方式</p><table><thead><tr><th>HTTP 1.0</th><th>HTTP 1.1</th></tr></thead><tbody><tr><td>GET</td><td>GET, POST, HEAD</td></tr><tr><td>POST</td><td>PUT</td></tr><tr><td>HEAD<br />要求服务器在响应报文中不包含请求对象 <br />故障跟踪</td><td>DELETE<br />删除URL字段规定的文件</td></tr></tbody></table><hr><p>再来看HTTP响应报文</p><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230903162547203.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230903162547203.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="HTTP响应报文"></p><p>响应报文中的第一行是状态行，常见的状态码：</p><p><strong>200 OK</strong> </p><ul><li>请求成功，请求对象包含在响应报文的后续部分</li></ul><p><strong>301 Moved Permanently</strong> </p><ul><li><p>请求的对象已经被永久转移了；新的URL在响应报文的Location:首部行中指定</p></li><li><p>客户端软件自动用新的URL去获取对象</p></li></ul><p><strong>400 Bad Request</strong> </p><ul><li>一个通用的差错代码，表示该请求不能被服务器解读</li></ul><p><strong>404 Not Found</strong> </p><ul><li>请求的文档在该服务上没有找到</li></ul><p><strong>505 HTTP Version Not Supported</strong></p><h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>HTTP是无状态的，下次访问就不认识了，就不能想B站、抖音那样给你个性化推荐。这时可以使用Cookies，不过目前技术先进网站使用的是token，这里就介绍一下Cookies。</p><p>Cookie 4个组成部分：</p><ol><li>在HTTP<strong>响应</strong>报文中有一个cookie的首部行</li><li>在HTTP<strong>请求</strong>报文含有一个cookie的首部行</li><li>在用户端系统中保留有一个<strong>cookie文件</strong>，由用户的浏览器管理</li><li>在Web站点有一个后端数据库</li></ol><p>例子：</p><ul><li>Susan总是用同一个PC使用Internet Explore上网</li><li>她第一次访问了一个使用了Cookie的电子商务网站</li><li>当最初的HTTP请求到达服务器时，该Web站点产生一个<strong>唯一的ID</strong>，并以此作为索引在它的<strong>后端数据库</strong>中产生一个项。</li></ul><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230903170932801.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20230903170932801.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230903170932801"></p><h2 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h2><p>Web缓存也叫代理服务器。缓存既是客户端又是服务器，通常缓存是由ISP安装 (大学、公司、居民区ISP)。</p><p>目标：不访问<strong>原始</strong>服务器，就满足客户的请求</p><ul><li>用户设置浏览器： 通过缓存访问Web</li><li>浏览器将所有的HTTP请求<strong>发给缓存</strong> <ul><li>在缓存中的对象：缓存<strong>直接返回对象</strong> </li><li>如对象不在缓存，缓存<strong>请求原始服务器</strong>，然后再将对象返回给客户端</li></ul></li></ul><p> Web缓存的作用</p><ul><li>降低客户端的请求响应时间</li><li>可以大大减少一个机构内部网络与Internent接入链路上的流量</li><li>互联网大量采用了缓存：可以使较弱的ICP也能够有效提供内容</li></ul><hr><h1 id="2-3-FTP"><a href="#2-3-FTP" class="headerlink" title="2.3 FTP"></a>2.3 FTP</h1><p>先来看看FTP是什么？FTP是文件传输协议，很明显是用来传文件的。现在分享文件都用什么？迅雷、百度云盘、QQ、微信群文件等。</p><p><img src="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20231029120024400.png" class="lazyload placeholder" data-srcset="/../images/%E7%AC%AC2%E7%AB%A0-%E5%BA%94%E7%94%A8%E5%B1%82/image-20231029120024400.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20231029120024400"></p><p>FTP连接过程：</p><ol><li><p><strong>FTP客户端</strong>（电脑）通过<strong>端口21</strong>与<strong>FTP服务器</strong>连接，<strong>TCP</strong>作为传输协议。</p></li><li><p>客户端通过TCP<strong>控制连接</strong></p><ul><li><p>2.1 进行<strong>身份认证</strong>。由于FTP比较古老，用户名和密码都是是明文传输，只需抓个包，账号就被看得一清二楚。</p></li><li><p>2.2 浏览远程目录，下载文件。</p></li></ul></li><li><p>服务器打开客户端的<strong>数据连接</strong>，端口20，发送文件给客户端。</p></li><li><p>发送完文件后，服务器关闭连接。</p></li></ol><p>–</p><p>另外，FTP连接是<strong>有状态的</strong>。</p><ul><li>FTP服务器维护用户的状态信息： 当前路径、用户帐户与控制连接对应。</li></ul><hr><h1 id="2-4-EMail"><a href="#2-4-EMail" class="headerlink" title="2.4 EMail"></a>2.4 EMail</h1><hr><p>2.5 DNS<br>2.6 P2P 应用<br>2.7 CDN<br>2.8 TCP 套接字编程<br>2.9 UDP 套接字编程</p><hr><p>视频</p><ul><li><a href="https://www.bilibili.com/video/BV1JV411t7ow/?p=14&spm_id_from=pageDriver&vd_source=49e30194f6d5798a1f90d69dad9c0460">2.2 Web and HTTP_哔哩哔哩_bilibili</a></li><li><a href="https://www.bilibili.com/video/BV1JV411t7ow/?p=15&spm_id_from=pageDriver&vd_source=49e30194f6d5798a1f90d69dad9c0460">2.3 FTP_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 应用层 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019CSP-J1真题</title>
      <link href="/2023/08/15/2019CSP-J1%E7%9C%9F%E9%A2%98/"/>
      <url>/2023/08/15/2019CSP-J1%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<blockquote><p>In Process</p></blockquote><h1 id="一、单项选择题"><a href="#一、单项选择题" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h1><p>第 1 题</p><p>中国的国家顶级域名是（）</p><p>A. .cn</p><p>B. .ch</p><p>C. .chn</p><p>D. .china</p><blockquote><p>选A。域名用<code>.</code>分割，最右边的是顶级域名，中国的国家顶级域名是.cn。 </p></blockquote><p>第 2 题</p><p>二进制数 11 1011 1001 0111 和 01 0110 1110 1011 进行逻辑与运算的结果是（）。</p><p>A. 01 0010 1000 1011</p><p>B. 01 0010 1001 0011</p><p>C. 01 0010 1000 0001</p><p>D. 01 0010 1000 0011</p><blockquote><p>选D。两位都为1，结果为1，否则为0。</p></blockquote><table><thead><tr><th></th><th align="left"></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td></td><td align="left">1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td></tr><tr><td>&amp;</td><td align="left">0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr><tr><td>&#x3D;</td><td align="left">0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr></tbody></table><p>第 3 题</p><p>一个 32 位整型变量占用（）个字节。</p><p>A. 32</p><p>B. 128</p><p>C. 4</p><p>D. 8</p><blockquote><p>选C。解析：在计算机中，数据存储的单位是字节(Byte),一个字节等于8位(bit)。一个32位整型变量，就是指这个变量可以存储32个二进制位，即4个字节。所以，一个32位整型变量占用4个字节。</p></blockquote><p>第 4 题</p><p>若有如下程序段，其中 <code>s</code>、<code>a</code>、<code>b</code>、<code>c</code> 均已定义为整型变量,且 <code>a</code>、<code>c</code> 均已赋值（<code>c</code> 大于 00）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = a;  </span><br><span class="line"><span class="keyword">for</span> （b = <span class="number">1</span>; b &lt;= c; b++） s = s - <span class="number">1</span>;  </span><br></pre></td></tr></table></figure><p>则与上述程序段功能等价的赋值语句是（）</p><p>A. <code>s = a - c;</code></p><p>B. <code>s = a - b;</code></p><p>C. <code>s = s - c;</code></p><p>D. <code>s = b - c;</code></p><blockquote><p>选A。解析：在程序段中，首先将变量 <code>a</code> 的值赋给变量 <code>s</code>，然后通过一个循环对 <code>s</code> 进行操作。循环的次数由变量 <code>c</code> 决定，每次循环都会使 <code>s</code> 的值减1。</p><p>如果我们要找到一个赋值语句，其功能与上述程序段等价，那么我们需要找到一个表达式，该表达式在执行后也会使 <code>s</code> 的值减1，并且减的次数等于 <code>c</code>。</p><p>选项A中的表达式 <code>s = a - c;</code> 符合这个要求。在程序段中，每次循环都会执行 <code>s = s - 1</code>，这会使 <code>s</code> 的值减去1。由于循环的次数由 <code>c</code> 决定，因此总共会进行 <code>c</code> 次减法操作，这就满足了题目的要求。</p></blockquote><p>第 5 题</p><p>设有 100 个已排好序的数据元素，采用折半查找时，最大比较次数为（）</p><p>A. 7</p><p>B. 10</p><p>C. 6 </p><p>D. 8</p><blockquote><p>选A。需要$\log _2 100$次，2的n中大于100的最小整数是$2^7 &#x3D; 128$，故最大次数为7。</p></blockquote><p>第 6 题</p><p>链表不具有的特点是（）</p><p>A. 插入删除不需要移动元素</p><p>B. 不必事先估计存储空间</p><p>C. 所需空间与线性表长度成正比</p><p>D. 可随机访问任一元素</p><blockquote><p>选D。解析：链表是一种常见的数据结构，它由一系列节点组成，每个节点包含两部分：数据域和指针域。数据域用于存储数据元素，而指针域用于存储下一个节点的地址。</p><p>选项A是正确的，因为链表的插入和删除操作只需要修改相邻节点的指针域，而不需要移动其他元素。这使得链表在插入和删除操作上比线性表更加高效。</p><p>选项B也是正确的，因为链表不必预先分配固定大小的存储空间。每当需要添加一个新元素时，只需分配一个新的节点，并将其添加到链表的末尾即可。这使得链表在内存使用上更加灵活。</p><p>选项C也是正确的，因为链表所需的存储空间与线性表的长度成正比。每个节点都需要额外的存储空间来存储指针域，而链表中的元素数量就是节点的数量。</p><p>然而，选项D是不正确的，因为链表不能随机访问任一元素。为了访问链表中的任一元素，必须从链表的头部开始遍历，直到找到目标元素或者到达链表的尾部。这种顺序访问的方式使得链表在随机访问上的性能较差于线性表。</p></blockquote><p>第 7 题</p><p>把 8 个同样的球放在 5 个同样的袋子里，允许有的袋子空着不放，问共有多少种不同的分法？（）</p><p>提示：如果 8 个球都放在一个袋子里，无论是哪个袋子，都只算同一种分法。</p><p>A. 22</p><p>B. 24</p><p>C. 18</p><p>D. 20</p><blockquote><p>选C。</p><p>4个空袋：1种</p><p>3个空袋：1+7，2+6，3+5，4+4</p><p>2个空袋：1+1+6，1+2+5，1+3+4，2+2+4，2+3+3</p><p>1个空袋：1+1+1+5，1+1+2+4，1+1+3+3，1+2+2+3，2+2+2+2</p><p>没有空袋：1+1+1+1+4，1+1+1+2+3，1+1+2+2+2</p></blockquote><p>第 8 题</p><p>一棵二叉树如右图所示，若采用顺序存储结构，即用一维数组元素存储该二叉树中的结点（根结点的下标为 1，若某结点的下标为 <em>i</em>，则其左孩子位于下标 2<em>i</em> 处、右孩子位于下标2<em>i</em>+1 处），则该数组的最大下标至少为（）。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/7d58dfs8.png?x-oss-process=image/resize,m_lfit,h_170,w_225" class="lazyload placeholder" data-srcset="https://cdn.luogu.com.cn/upload/image_hosting/7d58dfs8.png?x-oss-process=image/resize,m_lfit,h_170,w_225" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>A. 6</p><p>B. 10</p><p>C. 15</p><p>D. 12</p><blockquote><p>选C。 </p></blockquote><p><img src="/../images/2019CSP-J1%E7%9C%9F%E9%A2%98/image-20230815162747155.png" class="lazyload placeholder" data-srcset="/../images/2019CSP-J1%E7%9C%9F%E9%A2%98/image-20230815162747155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230815162747155"></p><p>第 9 题</p><p>100 以内最大的素数是（）。</p><p>A. 89</p><p>B. 97</p><p>C. 91</p><p>D. 93</p><blockquote><p>选B。</p></blockquote><p>第 10 题</p><p>319 和 377 的最大公约数是（）。</p><p>A. 27</p><p>B. 33</p><p>C. 29</p><p>D. 31</p><blockquote><p>选C。可以用辗转相除法。</p><ol><li>$377 % 319 &#x3D; 58$</li><li>$319 % 58 &#x3D; 29$</li><li>$58 % 29 &#x3D; 0$</li></ol><p>故答案为29。</p></blockquote><p>第 11 题</p><p>新学期开学了，小胖想减肥，健身教练给小胖制定了两个训练方案。</p><ul><li>方案一：每次连续跑 3 公里可以消耗 300 千卡（耗时半小时）；</li><li>方案二：每次连续跑 5 公里可以消耗 600 千卡（耗时 1 小时）。</li></ul><p>小胖每周周一到周四能抽出半小时跑步，周五到周日能抽出一小时跑步。<br>另外，教练建议小胖每周最多跑21公里，否则会损伤膝盖。<br>请问如果小胖想严格执行教练的训练方案，并且不想损伤膝盖，每周最多通过跑步消耗多少千卡？（）</p><p>A. 3000</p><p>B. 2500</p><p>C. 2400</p><p>D. 2520</p><blockquote><p>选C。3天跑一小时，2天跑半小时，共21公里，1800 + 600 &#x3D; 2400千卡。</p></blockquote><p>第 12 题</p><p>—副纸牌除掉大小王有 52张牌，四种花色，每种花色 13 张。</p><p>假设从这 52 张牌中随机抽取 13 张纸牌，则至少（）张牌的花色一致。</p><p>A. 4</p><p>B. 2</p><p>C. 3</p><p>D. 5</p><blockquote><p>选A。解析：这是一个应用鸽巢原理的问题。鸽巢原理，又称抽屉原理，是组合数学中的一个定理。其基本内容是：如果把$n+1$个物体放入$n$个盒子，那么至少有一个盒子里有两个物体。</p><p>在这个问题中，”鸽子”是52张牌，”鸽巢”是4种花色。我们需要从52张牌中抽取13张牌，那么根据鸽巢原理，至少有一个花色的牌数大于等于$\dfrac{13}{4}&#x3D;3.25$,向上取整得4。</p><p>所以至少4张牌的花色一致。</p></blockquote><p>第 13 题</p><p>—些数字可以颠倒过来看，例如 0,1,8 颠倒过来还是本身，6 颠倒过来是 9，9 颠倒过来看还是 6，其他数字颠倒过来都不构成数字。<br>类似的，一些多位数也可以颠倒过来看，比如 106 颠倒过来是 901。假设某个城市的车牌只由 5 位数字组成，每一位都可以取 0 到 9。<br>请问这个城市最多有多少个车牌倒过来恰好还是原来的车牌？（）</p><p>A. 60</p><p>B. 125</p><p>C. 75</p><p>D. 100</p><blockquote><p>选C。第1、2位有（0、1、8、6、9）五个数字，第3位有（0、1、8）三个数字，第4、5位由第1、2位决定(如第1位6，则第5位9）。<code>5 * 5 * 3 = 75</code></p></blockquote><p>第 14 题</p><p>假设一棵二叉树的后序遍历序列为 DGJHEBIFCA，中序遍历序列为 DBGEHJACIF，则其前序遍历序列为（）。</p><p>A. ABCDEFGHIJ</p><p>B. ABDEGHJCFI</p><p>C. ABDEGJHCFI</p><p>D. ABDEGHJFIC</p><blockquote><p>选B。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">    A --&gt; B &amp; C</span><br><span class="line">    B --&gt; D &amp; E</span><br><span class="line">    E --&gt; G &amp; H</span><br><span class="line">    H --&gt; J</span><br><span class="line"></span><br><span class="line">    C --&gt; S((NULL)) &amp; F</span><br><span class="line">    F --&gt; I &amp; Q((NULL))</span><br><span class="line"></span><br></pre></td></tr></table></figure><div class="mermaid">graph TB​A --&gt; B &amp; C​B --&gt; D &amp; E​E --&gt; G &amp; H​H --&gt; J​C --&gt; S((NULL)) &amp; F​F --&gt; I &amp; Q((NULL))</div><p>第 15 题</p><p>以下哪个奖项是计算机科学领域的最高奖？（）</p><p>A. 图灵奖</p><p>B. 鲁班奖</p><p>C. 诺贝尔奖</p><p>D. 普利策奖</p><blockquote><p>选A。</p></blockquote><hr><h1 id="二、阅读程序"><a href="#二、阅读程序" class="headerlink" title="二、阅读程序"></a>二、阅读程序</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> st[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, st);</span><br><span class="line">    <span class="type">int</span> n = <span class="built_in">strlen</span>(st);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">char</span> c = st[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (c &gt;= <span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                st[i - <span class="number">1</span>] = c - <span class="string">&#x27;a&#x27;</span> + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, st);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入字符串，序号是n的约数的字符，小写转大写。</p></blockquote><p>判断题</p><p>1）输入的字符串只能由小写字母或大写字母组成。（ × ）</p><p>2）若将第 8 行的 <code>i = 1</code> 改为 <code>i = 0</code>，程序运行时会发生错误。（  √  ）</p><p>3）若将第 8 行的 <code>i &lt;= n</code> 改为 <code>i * i &lt;= n</code>，程序运行结果不会改变。（ × ）</p><p>4）若输入的字符串全部由大写字母组成，那么输出的字符串就跟输入的字符串一样。（ √ ）</p><p>选择题</p><p>5）若输入的字符串长度为 18，那么输入的字符串跟输出的字符串相比，至多有（）个字符不同。</p><p>A. 18</p><p>B. 6</p><p>C. 10</p><p>D. 1</p><blockquote><p>选B。1、2、3、6、9、18。</p></blockquote><p>6）若输入的字符串长度为（），那么输入的字符串跟输出的字符串相比，至多有 36 个字符不同。</p><p>A. 36</p><p>B. 100000</p><p>C. 1</p><p>D. 128</p><blockquote><p>选B。$100000 &#x3D; 2^5 \times 5^5$，2可以取$2^0, 2^1…2^5$，有6种取法，5有6种取法，共有36种取法。</p></blockquote><h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> a[<span class="number">100</span>], b[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = b[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="keyword">if</span> (a[x] &lt; y &amp;&amp; b[y] &lt; x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[x] &gt; <span class="number">0</span>)</span><br><span class="line">                b[a[x]] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (b[y] &gt; <span class="number">0</span>)</span><br><span class="line">                a[b[y]] = <span class="number">0</span>;</span><br><span class="line">            a[x] = y;</span><br><span class="line">            b[y] = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">0</span>)</span><br><span class="line">            ++ans;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>)</span><br><span class="line">            ++ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设输入的 <em>n</em> 和 <em>m</em> 都是正整数，<em>x</em> 和 <em>y</em> 都是在 <code>[1, n]</code> 的范围内的整数，完成下面的判断题和单选题：</p><blockquote><p>跟最大匹配问题有点像，详情可参考该文章<a href="https://zhuanlan.zhihu.com/p/640006860">最大匹配问题——匈牙利算法通俗理解 - 知乎 (zhihu.com)</a>。</p><p>两个数组，可以看作二分图，输入x，y配对，最后统计处未匹配的元素个数。</p><p>代码的主要逻辑如下：</p><ol><li>首先，定义了两个整型数组a和b，用于存储每个元素的匹配情况。初始时，所有元素都被标记为未匹配（0）。</li><li>然后，通过循环读取输入的配对关系，并更新数组a和b中的匹配情况。如果当前配对关系中的两个元素可以互相匹配（即a[x] &lt; y且b[y] &lt; x），则将它们互相匹配，并将原来的匹配关系置为未匹配。</li><li>最后，遍历数组a和b，统计未匹配的元素个数。</li></ol></blockquote><p>判断题</p><p>1）当 <em>m</em>&gt;0  时，输出的值一定小于 2n。（ √ ）</p><p>2）执行完第 27 行的 <code>++ans</code> 时，ans —定是偶数。（ × ）</p><blockquote><p>在for循环执行的过程中，ans未统计完，有可能为奇数。</p><p>for循环执行完后，ans—定是偶数。</p></blockquote><p>3）<code>a[i]</code> 和 <code>b[i]</code> 不可能同时大于 0。（ × ）</p><blockquote><p>m &#x3D; 1，x &#x3D; 2，y &#x3D; 2时，<code>a[i]</code>和<code>b[i]</code>同时为2。</p></blockquote><p>4）若程序执行到第 13 行时，<em>x</em> 总是小于 <em>y</em>，那么第 15 行不会被执行。（ × ）</p><blockquote><p>不一定能够，如（1, 2）、（1,3）。</p></blockquote><p>选择题</p><p>5）若 <em>m</em> 个 <em>x</em> 两两不同，且 <em>m</em> 个 <em>y</em> 两两不同，则输出的值为（）</p><p>A. 2<em>n</em>−2<em>m</em></p><p>B. 2<em>n</em>+2</p><p>C. 2<em>n</em>−2</p><p>D. 2<em>n</em></p><blockquote><p>选A。输出未匹配的值，最终匹配2m个数，一共有2n个数，gu为2n - 2m。</p></blockquote><p>6）若 <em>m</em> 个 <em>x</em> 两两不同，且 <em>m</em> 个 <em>y</em> 都相等，则输出的值为（）</p><p>A.  2<em>n</em>−2</p><p>B. 2<em>n</em></p><p>C. 2<em>m</em></p><p>D. 2<em>n</em>−2<em>m</em></p><blockquote><p>选A。最终只匹配一对，减去2个。</p></blockquote><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> b[maxn];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &gt; r)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> min = maxn, mink;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= r; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; a[i]) &#123;</span><br><span class="line">            min = a[i];</span><br><span class="line">            mink = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> lres = <span class="built_in">f</span>(l, mink - <span class="number">1</span>, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> rres = <span class="built_in">f</span>(mink + <span class="number">1</span>, r, depth + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> lres + rres + depth * b[mink];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        cin &gt;&gt; b[i];</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(<span class="number">0</span>, n - <span class="number">1</span>, <span class="number">1</span>) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>将数组b根据数组a的值构造成一棵二叉树，二叉树的节点是b数组的元素。每次在序列中选择a值最小且最靠前的元素作为根，根左侧的序列构建左子树，根右侧的序列构建右子树，递归求解。最后求每个节点值b[i]乘深度depth的和。</p></blockquote><p>判断题</p><p>1）如果 <em>a</em> 数组有重复的数字，则程序运行时会发生错误。（ × ）</p><blockquote><p>如果重复，判断条件是<code>if (min &gt; a[i])</code>，<code>min == a[i]</code>时不管，找第一个最小值，无影响。</p></blockquote><p>2）如果 <em>b</em> 数组全为 0，则输出为 0。（ √ ）</p><p>选择题</p><p>3）当 <em>n</em>&#x3D;100 时，最坏情况下，与第 12 行的比较运算执行的次数最接近的是：（）。</p><p>A. 5000</p><p>B. 600</p><p>C. 6</p><p>D. 100</p><blockquote><p>选A。最坏情况，每次min都在最左边或最右边，每层只少一个点，即比较次数每层少1，总次数为$100 + 99 + … + 1 &#x3D; 5050$</p></blockquote><p>4）当 <em>n</em>&#x3D;100 时，最好情况下，与第 12 行的比较运算执行的次数最接近的是：（）。</p><p>A. 100</p><p>B. 6</p><p>C. 5000 </p><p>D. 600</p><blockquote><p>选D。最好情况，每次min都在中间，要分$log_2100$次，即深度，大概为6，每层大概执行100次。</p></blockquote><p>5）当<em>n</em>&#x3D;10 时，若 <em>b</em> 数组满足，对任意 0≤<em>i</em>&lt;<em>n</em>，都有 <code>b[i] = i + 1</code>，那么输出最大为（）。</p><p>A. 386</p><p>B. 383</p><p>C. 384</p><p>D. 385</p><blockquote><p>选D。</p></blockquote><p><img src="/../images/2019CSP-J1%E7%9C%9F%E9%A2%98/image-20230818184041810.png" class="lazyload placeholder" data-srcset="/../images/2019CSP-J1%E7%9C%9F%E9%A2%98/image-20230818184041810.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818184041810"></p><p>6）当 <em>n</em>&#x3D;100 时，若 <em>b</em> 数组满足，对任意 0≤<em>i</em>&lt;<em>n</em>，都有 <code>b[i]=1</code>，那么输出最小为（）。</p><p>A. 582</p><p>B. 580</p><p>C. 579</p><p>D. 581</p><blockquote><p>选B。</p></blockquote><p><img src="/../images/2019CSP-J1%E7%9C%9F%E9%A2%98/image-20230818184146801.png" class="lazyload placeholder" data-srcset="/../images/2019CSP-J1%E7%9C%9F%E9%A2%98/image-20230818184146801.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818184146801"></p><hr><h1 id="三、完善程序"><a href="#三、完善程序" class="headerlink" title="三、完善程序"></a>三、完善程序</h1><h2 id="3-1-矩阵变幻"><a href="#3-1-矩阵变幻" class="headerlink" title="3.1 矩阵变幻"></a>3.1 矩阵变幻</h2><p>有一个奇幻的矩阵，在不停的变幻，其变幻方式为：</p><p>数字 0 变成矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 0 </span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><p>数字 1 变成矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1 1</span><br><span class="line">1 0</span><br></pre></td></tr></table></figure><p>最初该矩阵只有一个元素 0，变幻 <em>n</em> 次后，矩阵会变成什么样？</p><p>例如，矩阵最初为：[0]；</p><p>矩阵变幻 1 次后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 0 </span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><p>矩阵变幻 2 次后：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 0</span><br><span class="line">0 1 0 1</span><br><span class="line">0 0 1 1</span><br><span class="line">0 1 1 0</span><br></pre></td></tr></table></figure><p>输入一行一个不超过 10 的正整数 n。输出变幻 n 次后的矩阵。</p><p>试补全程序。</p><p>提示：</p><p><code>&lt;&lt;</code> 表示二进制左移运算符，例如 $(11)_2(11)_2$ <code>&lt;&lt; 2</code>  &#x3D; $(1100)_2$<br>而 <code>^</code> 表示二进制异或运算符，它将两个参与运算的数中的每个对应的二进制位—进行比较，若两个二进制位相同，则运算结果的对应二进制位为 0 ，反之为 1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> max_size = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> res[max_size][max_size];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">recursive</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> n, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        res[x][y] = ①;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> step = <span class="number">1</span> &lt;&lt; (n - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">recursive</span>(②, n - <span class="number">1</span>, t);</span><br><span class="line">    <span class="built_in">recursive</span>(x, y + step, n - <span class="number">1</span>, t);</span><br><span class="line">    <span class="built_in">recursive</span>(x + step, y, n - <span class="number">1</span>, t);</span><br><span class="line">    <span class="built_in">recursive</span>(③, n - <span class="number">1</span>, !t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">recursive</span>(<span class="number">0</span>, <span class="number">0</span>, ④);</span><br><span class="line">    <span class="type">int</span> size = ⑤;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; size; j++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, res[i][j]);</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>①处应填（）</p><p>A. <code>n%2</code></p><p>B. <code>0</code></p><p>C. <code>t</code></p><p>D. <code>1</code></p><blockquote><p>选C。</p></blockquote><p>②处应填（）</p><p>A. <code>x-step,y-step</code></p><p>B. <code>x,y-step</code></p><p>C. <code>x-step,y</code></p><p>D. <code>x,y</code></p><blockquote><p>选D。举例：一开始为0，<code>n = 1</code>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0 0 </span><br><span class="line">0 1</span><br></pre></td></tr></table></figure><blockquote><p>起始坐标为（0,0）</p><p>第一行：第一个0为当前坐标，第二个0为（0,0 + 1）</p><p>第二行：第一个0为（0 + 1,0 ），第二个1为（0+1,0+1）</p><p>代码中已有右边 和 下边两个坐标，还差 当前坐标 和 右下坐标。</p></blockquote><p>③处应填（）</p><p>A. <code>x-step,y-step</code></p><p>B. <code>x+step,y+step</code></p><p>C. <code>x-step,y</code></p><p>D. <code>x,y-step</code></p><blockquote><p>选B。</p></blockquote><p>④处应填（）</p><p>A. <code>n-1,n%2</code></p><p>B. <code>n,0</code></p><p>C. <code>n,n%2</code></p><p>D. <code>n-1,0</code></p><blockquote><p>选B。n是矩阵大小，初始为n。</p><p>前3个递归调用函数参数为<code>t</code>，最后一个调用参数为 <code>!t</code>，<code>t</code>的初始值为0。</p></blockquote><p>⑤处应填（）</p><p>A. <code>1&lt;&lt;(n+1)</code></p><p>B. <code>1&lt;&lt;n</code></p><p>C. <code>n+1</code></p><p>D. <code>1&lt;&lt;(n-1)</code></p><blockquote><p>选B。</p><p>n &#x3D; 1：size &#x3D; 2</p><p>n &#x3D; 2:  size &#x3D; 4</p><p>size为$2^n$，位运算<code>1 &lt;&lt; n</code></p></blockquote><h2 id="3-2-计数排序"><a href="#3-2-计数排序" class="headerlink" title="3.2 计数排序"></a>3.2 计数排序</h2><p>计数排序是一个广泛使用的排序方法。下面的程序使用双关键字计数排序，将 <em>n</em> 对 10000 以内的整数，从小到大排序。</p><p>例如有三对整数 (3,4)、(2,4)、(3,3)，那么排序之后应该是 (2,4)、(3,3)、(3,4) 。</p><p>输入第一行为 <em>n</em>，接下来 <em>n</em> 行，第 <em>i</em> 行有两个数 a[i] 和<em>b</em>[<em>i</em>]，分别表示第 <em>i</em> 对整数的第一关键字和第二关键字。</p><p>从小到大排序后输出。</p><p>数据范围 1&lt;<em>n</em>&lt;$10^7$，1&lt;<em>a</em>[<em>i</em>]，<em>b</em>[<em>i</em>]&lt;$10^4$。</p><p>提示：应先对第二关键字排序，再对第一关键字排序。数组 <code>ord[]</code> 存储第二关键字排序的结果，数组 <code>res[]</code> 存储双关键字排序的结果。</p><p>试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">10000000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxs = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">unsigned</span> a[maxn], b[maxn],res[maxn], ord[maxn];</span><br><span class="line"><span class="type">unsigned</span> cnt[maxs + <span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a[i], &amp;b[i]);</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ①; <span class="comment">// 利用 cnt 数组统计数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxs; ++i) </span><br><span class="line">        cnt[i + <span class="number">1</span>] += cnt[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ②; <span class="comment">// 记录初步排序结果</span></span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">        ③; <span class="comment">// 利用 cnt 数组统计数量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; maxs; ++i)</span><br><span class="line">        cnt[i + <span class="number">1</span>] += cnt[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">        ④ <span class="comment">// 记录最终排序结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d&quot;</span>, ⑤);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/2019CSP-J1%E7%9C%9F%E9%A2%98/image-20230818220737984.png" class="lazyload placeholder" data-srcset="/../images/2019CSP-J1%E7%9C%9F%E9%A2%98/image-20230818220737984.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818220737984"></p><p>①处应填（）</p><p>A. <code>++cnt[i]</code></p><p>B. <code>++cnt[b[i]]</code></p><p>C. <code>++cnt[a[i] * maxs + b[i]]</code></p><p>D. <code>++cnt[a[i]]</code></p><blockquote><p>选B。先对第二关键字桶计数。</p></blockquote><p>②处应填（）</p><p>A. <code>ord[--cnt[a[i]]] = i</code></p><p>B. <code>ord[--cnt[b[i]]] = a[i]</code></p><p>C. <code>ord[--cnt[a[i]]] = b[i]</code></p><p>D. <code>ord[--cnt[b[i]]] = i</code></p><blockquote><p>选D。升序排序。</p></blockquote><p>③处应填（）</p><p>A. <code>++cnt[b[i]]</code></p><p>B. <code>++cnt[a[i] * maxs + b[i]]</code></p><p>C. <code>++cnt[a[i]]</code></p><p>D. <code>++cnt[i]</code></p><blockquote><p>选C。对第一关键字桶计数。</p></blockquote><p>④处应填（）</p><p>A. <code>res[--cnt[a[ord[i]]]] = ord[i]</code></p><p>B. <code>res[--cnt[b[ord[i]]]] = ord[i]</code></p><p>C. <code>res[--cnt[b[i]]] = ord[i]</code></p><p>D. <code>res[--cnt[a[i]]] = ord[i]</code></p><blockquote><p>选A。</p></blockquote><p>⑤处应填（）</p><p>A. <code>a[i], b[i]</code></p><p>B. <code>a[res[i]], b[res[i]]</code></p><p>C. <code>a[ord[res[i]]],b[ord[res[i]]]</code></p><p>D. <code>a[res[ord[i]]],b[res[ord[i]]]</code></p><blockquote><p>选B。res[i]记录的是第i个数在原序列的位置。</p></blockquote><hr><p>参考</p><ul><li><p><a href="https://ti.luogu.com.cn/problemset/1030">1030 - CSP 2019 入门级第一轮 - 洛谷有题 (luogu.com.cn)</a> </p></li><li><p><a href="https://www.bilibili.com/video/BV1JG411t7iV/?spm_id_from=333.788&vd_source=49e30194f6d5798a1f90d69dad9c0460">2019年CSP-J入门级初赛（第一轮）真题讲解_哔哩哔哩_bilibili</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2019CSP-J1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2020CSP-J1真题</title>
      <link href="/2023/08/14/2020CSP-J1%E7%9C%9F%E9%A2%98/"/>
      <url>/2023/08/14/2020CSP-J1%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、单向选择题"><a href="#一、单向选择题" class="headerlink" title="一、单向选择题"></a>一、单向选择题</h1><p>第 1 题</p><p>在内存储器中每个存储单元都被赋予一个唯一的序号，称为（）。</p><p>A. 地址</p><p>B. 序号</p><p>C. 下标</p><p>D. 编号</p><blockquote><p>选A。内存储器是计算机中的一种存储设备，用于存储程序和数据。每个存储单元都被赋予一个唯一的序号，称为地址。地址是内存中的一个位置，它是由二进制数字表示的，用于定位内存中的特定位置。在计算机中，地址通常是由处理器读取的，以访问内存中的特定位置。</p></blockquote><p>第 2 题</p><p>编译器的主要功能是（ ）。</p><p>A. 将源程序翻译成机器指令代码</p><p>B. 将源程序重新组合</p><p>C. 将低级语言翻译成高级语言</p><p>D. 将一种高级语言翻译成另一种高级语言</p><blockquote><p>选A。编译器是一种程序，它将一种高级语言编写的程序转换成目标语言（通常为低级语言）的程序。编译器能够识别代码中的词汇、句子以及各种特定的格式，并将他们转换成计算机能够识别的二进制形式，这个过程称为编译 。</p><p>编译器的主要功能包括：将源代码翻译成目标代码、进行语义检查、优化和生成目标文件等 。</p></blockquote><p>第 3 题</p><p>设 <code>x=true,y=true,z=false</code>，以下逻辑运算表达式值为真的是（ ）。</p><p>A. (y∨z)∧x∧z</p><p>B. x∧(z∨y) ∧z</p><p>C. (x∧y) ∧z</p><p>D. (x∧y)∨(z∨x)</p><blockquote><p>选D。有一个<code>^z</code>，值为假。</p></blockquote><p>第 4 题</p><p>现有一张分辨率为 2048×1024 像素的 32 位真彩色图像。请问要存储这张图像，需要多大的存储空间？（ ）。</p><p>A. 16MB</p><p>B. 4MB</p><p>C. 8MB</p><p>D. 2MB</p><blockquote><p>选C。用32位二进制数表示1个像素的颜色，即一个像素32个bit，转换成Byte：32 &#x2F; 8 &#x3D; 4 Byte。</p></blockquote><p>$$<br>\frac{32}{8} * 2048 * 1024 \<br>&#x3D; 4 * 2^{11} * 2^{10} \<br>&#x3D; 2^2 * 2^{21} B \<br>&#x3D; \frac{2^{23}}{2^{20}}MB &#x3D; 2^3 MB &#x3D; 8 MB<br>$$</p><p>第 5 题</p><p>冒泡排序算法的伪代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入：数组L, n ≥ k。输出：按非递减顺序排序的 L。</span><br><span class="line">算法 BubbleSort：</span><br><span class="line">   <span class="number">1.</span> FLAG ← n <span class="comment">//标记被交换的最后元素位置</span></span><br><span class="line">   <span class="number">2.</span> <span class="keyword">while</span> FLAG &gt; <span class="number">1</span> <span class="keyword">do</span></span><br><span class="line">   <span class="number">3.</span>     k ← FLAG <span class="number">-1</span></span><br><span class="line">   <span class="number">4.</span>     FLAG ← <span class="number">1</span></span><br><span class="line">   <span class="number">5.</span>     <span class="keyword">for</span> j=<span class="number">1</span> to k <span class="keyword">do</span></span><br><span class="line">   <span class="number">6.</span>         <span class="keyword">if</span> <span class="built_in">L</span>(j) &gt; <span class="built_in">L</span>(j+<span class="number">1</span>) then <span class="keyword">do</span></span><br><span class="line">   <span class="number">7.</span>              <span class="built_in">L</span>(j)  ↔ <span class="built_in">L</span>(j+<span class="number">1</span>)</span><br><span class="line">   <span class="number">8.</span>              FLAG ← j</span><br></pre></td></tr></table></figure><p>对 <em>n</em> 个数用以上冒泡排序算法进行排序，最少需要比较多少次?（ ）。</p><p>A. $n^2$</p><p>B. n−2 </p><p>C. n−1 </p><p>D. n</p><blockquote><p>选C。最好情况，程序已经排好序，n个数要比较n - 1次。</p></blockquote><p>第 6 题</p><p>设 <em>A</em> 是 <em>n</em> 个实数的数组，考虑下面的递归算法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">XYZ</span> (A[<span class="number">1.</span>.n])</span><br><span class="line"><span class="keyword">if</span> n=<span class="number">1</span> then <span class="keyword">return</span> A[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">else</span> temp ← <span class="built_in">XYZ</span> (A[<span class="number">1.</span>.n<span class="number">-1</span>])</span><br><span class="line">    <span class="keyword">if</span> temp &lt; A[n]</span><br><span class="line">    then <span class="keyword">return</span> temp</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> A[n]</span><br></pre></td></tr></table></figure><p>请问算法 XYZ 的输出是什么？（）。</p><p>A. A 数组的平均</p><p>B. A 数组的最小值</p><p>C. A 数组的中值</p><p>D. A 数组的最大值</p><blockquote><p>选B。</p><p>这个递归算法是一种简单的选择排序，它用于在数组中查找最小值。让我们逐步解释算法的工作原理：</p><ol><li><p>如果数组只有一个元素（n&#x3D;1），那么最小值就是该元素本身，直接返回 A[1]。</p></li><li><p>否则，我们递归地调用 XYZ 函数来对前 n-1 个元素进行排序，并将结果存储在临时变量 temp 中。</p></li><li><p>然后，我们将第 n 个元素与 temp 进行比较。</p></li><li><p>如果 temp 小于第 n 个元素，说明在第 n-1 个元素中已经找到了最小值，因此我们可以直接返回 temp。</p></li><li><p>否则，第 n 个元素就是最小的元素，我们将其返回。</p></li></ol><p>通过递归地将问题分解为更小的子问题，并在每个子问题上选择最小值，最终算法会找到整个数组中的最小值并返回。因此，答案是 B. A 数组的最小值。</p></blockquote><p>第 7 题</p><p>链表不具有的特点是（）。</p><p>A. 可随机访问任一元素</p><p>B. 不必事先估计存储空间</p><p>C. 插入删除不需要移动元素</p><p>D. 所需空间与线性表长度成正比</p><blockquote><p>选A. 可随机访问任一元素。</p><p>链表是一种线性数据结构，其中的元素不是连续存储的。每个元素都包含一个指向下一个元素的指针。因此，要访问链表中的任一元素，必须先遍历到该元素所在的节点，然后通过节点中的指针来访问该元素。由于需要遍历，所以链表不能像数组那样直接通过索引来访问任一元素，因此不具备随机访问任一元素的特点。</p></blockquote><p>第 8 题</p><p>有 10 个顶点的无向图至少应该有（ ）条边才能确保是一个连通图。</p><p>A. 9</p><p>B. 10</p><p>C. 11</p><p>D. 12</p><blockquote><p>选A。一个无向图的连通性是指图中任意两个顶点都存在一条路径相连。</p><p>对于有n个顶点的无向图，其连通性至少需要满足的条件是：当且仅当图中含有n-1条边时，这个图才是连通的。</p><p>因此，对于有10个顶点的无向图，至少需要9条边才能确保它是连通图。这是因为当图中只有8条边时，这个图就不是一个连通图。</p><p>举个例子，考虑一个有4个顶点的无向图，它只有3条边，所以它不是一个连通图。但是如果我们添加第4条边，这个图就变成了一个连通图。</p></blockquote><p>第 9 题</p><p>二进制数 1011 转换成十进制数是（ ）。</p><p>A. 11</p><p>B. 10</p><p>C. 13</p><p>D. 12</p><blockquote><p>选A。我们可以通过将二进制数的每一位乘以$2^n$(其中$n$为该位上的数字),然后将结果相加来将二进制数转换为十进制数。二进制数1011的转换过程如下：$1\times2^3+0\times2^2+1\times2^1+1\times2^0&#x3D;11$</p></blockquote><p>第 10 题</p><p>5 个小朋友并排站成一列，其中有两个小朋友是双胞胎，如果要求这两个双胞胎必须相邻，则有（ ）种不同排列方法?</p><p>A. 48</p><p>B. 36</p><p>C. 24</p><p>D. 72</p><blockquote><p>选A。我们可以把双胞胎看作一个整体，那么就有4个整体(3个小朋友和一个双胞胎整体)需要排列，共有$4!&#x3D;24$种排列方法。而双胞胎之间又有2种排列方法。所以总的排列方法为$24\times2$ $&#x3D;48$种。</p></blockquote><p>第 11 题</p><p>下图中所使用的数据结构是（ )。</p><p><img src="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230827215440091.png" class="lazyload placeholder" data-srcset="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230827215440091.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230827215440091"></p><p>A. 栈</p><p>B. 队列</p><p>C. 二叉树</p><p>D. 哈希表</p><blockquote><p>选A。先入后出，是栈。</p></blockquote><p>第 12 题</p><p>独根树的高度为 1。具有 61 个结点的完全二叉树的高度为（ ）。</p><p>A. 7</p><p>B. 8</p><p>C. 5</p><p>D. 6</p><blockquote><p>选D。</p><p>解析：根据二叉树的性质，由于高度h的<strong>满二叉树</strong>共有$2^{h}-1$个结点，所以满二叉树的高度为 $\log_2(n+1)$，其中 n 为结点个数。</p><ul><li>高度h的<strong>完全二叉树</strong>至少有$2^{h-1}$个结点</li><li>高度h的<strong>完全二叉树</strong>至多有$2^h-1$个结点.</li></ul><p>因此，具有 61 个结点的完全二叉树的高度为 $\lfloor \log_2(61) \rfloor + 1 &#x3D; \lfloor \log_2(61) \rfloor + 1 &#x3D; 6$。</p></blockquote><blockquote><p>第1层有1个结点，第2层有2个结点，第3层有4个，每次都是乘2，从二进制数的角度看，就是左移一位。</p><p>第1层有1个结点，第2层有10个结点，第3层有100个。</p><p>高度为2的满二叉树共有 1 + 10 &#x3D; 11 个结点，高度为3的满二叉树共有 100 + 11 &#x3D; 111 个结点。</p></blockquote><p>第 13 题</p><p>干支纪年法是中国传统的纪年方法，由 10 个天干和 12 个地支组合成 60 个天干地支。由公历年份可以根据以下公式和表格换算出对应的天干地支。</p><ul><li>天干 &#x3D;（公历年份）除以 10 所得余数</li><li>地支 &#x3D;（公历年份）除以 12 所得余数</li></ul><p><img src="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230826213936387.png" class="lazyload placeholder" data-srcset="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230826213936387.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230826213936387"></p><p>例如，今年是 2020 年，2020 除以 10 余数为 0，查表为”庚”；2020 除以 12，余数为 4，查表为“子” 所以今年是庚子年。</p><p>请问 1949 年的天干地支是（ ）</p><p>A. 己酉</p><p>B. 己亥</p><p>C. 己丑</p><p>D. 己卯</p><blockquote><p>选C。首先，我们需要计算1949年除以10和12的余数。</p><p>$1949\div10$ $&#x3D;194.9$,余数为9。</p><p>$1949\div12$ $&#x3D;1949&#x2F;12$,余数为5。</p><p>1949年的天干是9,地支是5，天干地支是己丑。</p></blockquote><p>第 14 题</p><p>10 个三好学生名额分配到 7 个班级，每个班级至少有一个名额，一共有（ ）种不同的分配方案。</p><p>A. 84</p><p>B. 72</p><p>C. 56</p><p>D. 504</p><blockquote><p>选A。可将10个学生看成10个元素，一字排开，元素之间形成9个空。在9个空中插入6块板即可将其分为7部分，则共有$C_9^6&#x3D;84$种方案。</p></blockquote><p>第 15 题</p><p>有五副不同颜色的手套（共 10 只手套，每副手套左右手各 1 只），一次性从中取 6 只手套，请问恰好能配成两副手套的不同取法有（ ）种。</p><p>A. 120</p><p>B. 180</p><p>C. 150</p><p>D. 30</p><blockquote><p>选A。恰好能配成两幅手套，那么只能是$5$只手套成一副，剩下1只手套。</p><p>所以先从5副中取2副，有$C_5^2&#x3D;10$种，</p><p>再从剩下的6只中，取第5个，6种取法，</p><p>从剩下的5只中，取第6个，不能与第5个相同，只有2种取法，</p><p>共有$C_5^2\times 6 \times \times 2&#x3D;120$种。</p></blockquote><hr><h1 id="二、阅读程序"><a href="#二、阅读程序" class="headerlink" title="二、阅读程序"></a>二、阅读程序</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> encoder[<span class="number">26</span>] = &#123;<span class="string">&#x27;C&#x27;</span>,<span class="string">&#x27;S&#x27;</span>,<span class="string">&#x27;P&#x27;</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">char</span> decoder[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">string st;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        <span class="keyword">if</span> (encoder[i] != <span class="number">0</span>) ++k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> x =<span class="string">&#x27;A&#x27;</span>; x &lt;= <span class="string">&#x27;Z&#x27;</span>; ++x) &#123;</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (encoder[i] ==x) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            encoder[k]= x;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">        decoder[encoder[i]- <span class="string">&#x27;A&#x27;</span>] = i + <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; st.<span class="built_in">length</span>( ); ++i)</span><br><span class="line">        st[i] = decoder[st[i] -<span class="string">&#x27;A&#x27;</span>];</span><br><span class="line">    cout &lt;&lt; st;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p> 这个程序实现了一个简单的字符编码器和解码器。它使用了两个数组，<code>encoder</code>和<code>decoder</code>，分别用于存储编码后的字符和解码后的字符。初始时，<code>encoder</code>数组中已经包含了一些字符（’C’、’S’、’P’），这些字符被用作起始的编码映射。</p><p>程序首先通过遍历<code>encoder</code>数组来计算实际使用的字符个数，即变量<code>k</code>的值。然后，它使用一个循环来遍历字母表中的大写字母（从’A’到’Z’），并检查每个字母是否已经在<code>encoder</code>数组中出现过。如果某个字母没有出现过，就将其添加到<code>encoder</code>数组中，并增加<code>k</code>的值。</p><p>接下来，程序使用另一个循环来构建<code>decoder</code>数组，将编码后的字符映射回原始字符。具体来说，它将<code>encoder</code>数组中的每个元素减去’A’的ASCII值，然后将索引值加上’A’的ASCII值，得到对应的原始字符的索引。这样就建立了编码和解码之间的映射关系。</p><p>程序接着读取输入的字符串<code>st</code>，并使用循环遍历该字符串的每个字符。对于每个字符，它通过查找<code>decoder</code>数组来获取对应的原始字符，并将其替换为原始字符。最后，程序输出解码后的字符串<code>st</code>。</p><p>总结起来，这段程序实现了一个简单的编码器和解码器，可以将输入的字符串进行编码和解码操作。</p></blockquote><p><img src="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230814221412265.png" class="lazyload placeholder" data-srcset="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230814221412265.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814221412265"></p><p><img src="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230814221909281.png" class="lazyload placeholder" data-srcset="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230814221909281.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814221909281"></p><p>判断题</p><p>16、输入的字符串应当只由大写字母组成，否则在访问数组时可能越界。（ 正确 ）</p><blockquote><p>如果输入小写字母‘a’，<code>st[i] - &#39;A&#39;</code>大于25。</p></blockquote><p>17、若输入的字符串不是空串，则输入的字符串与输出的字符串一定不一样。（ 错误 ）</p><blockquote><p>输入T，输出也为T。</p></blockquote><p>18、将第 12 行的 <code>i &lt; 26</code> 改为 <code>i &lt; 16</code>，程序运行结果不会改变。（ 正确  ）</p><blockquote><p>就三个字符C S P，执行3次就够了，<code>i &lt; 16</code>结果一样。</p></blockquote><p>19、将第 26 行的 <code>i &lt; 26</code> 改为 <code>i &lt; 16</code>，程序运行结果不会改变。（ 错误 ）</p><blockquote><p> decode要解码26个字符，16不够，结果不一样。</p></blockquote><p>单选题</p><p>20、若输出的字符串为ABCABCABCA，则下列说法正确的是（ ）。</p><p>A. 输入的字符串中既有 S 又有 P</p><p>B. 输入的字符串中既有 S 又有 B</p><p>C. 输入的字符串中既有 A 又有 P</p><p>D. 输入的字符串中既有 A 又有 B</p><blockquote><p>选A。看上面解析图片。</p></blockquote><p>21、若输出的字符串为 CSPCSPCSPCSP，则下列说法正确的是（ ）。</p><p>A. 输入的字符串中既有 P 又有 K</p><p>B. 输入的字符串中既有 J 又有 R</p><p>C. 输入的字符串中既有 J 又有 K</p><p>D. 输入的字符串中既有 P 又有 R</p><blockquote><p>选D。看上面解析图片。</p></blockquote><h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, ans; <span class="comment">// 定义长整型变量n和ans，其中n用于存储数组的长度，ans用于存储进位次数</span></span><br><span class="line"><span class="type">int</span> k, len; <span class="comment">// 定义整型变量k和len，k进制，len用于存储当前k进制数的长度</span></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> d[<span class="number">1000000</span>]; <span class="comment">// 定义一个长整型数组d，用于存储输出结果，d[0]是最后一位，d[len-1]是最高位</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k; <span class="comment">// 从输入流中读取n和k的值</span></span><br><span class="line">    d[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// k进制最后一位初值为0</span></span><br><span class="line">    len = <span class="number">1</span>; <span class="comment">// 0的总位数是1</span></span><br><span class="line">    ans = <span class="number">0</span>; <span class="comment">// 进位次数是0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; i &lt;n; ++i) &#123; <span class="comment">// 遍历数列中的每个元素</span></span><br><span class="line">        ++d[<span class="number">0</span>]; <span class="comment">// 最后一位加1</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + <span class="number">1</span>&lt;len; ++j) &#123; <span class="comment">// 0到len-2，处理进位</span></span><br><span class="line">            <span class="keyword">if</span> (d[j] == k) &#123; <span class="comment">// 第j位为k</span></span><br><span class="line">                d[j] = <span class="number">0</span>; <span class="comment">// j位清0</span></span><br><span class="line">                d[j + <span class="number">1</span>] += <span class="number">1</span>; <span class="comment">// 高位进1</span></span><br><span class="line">                ++ans; <span class="comment">// 进位次数加1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (d[len- <span class="number">1</span>] == k) &#123; <span class="comment">// 上面的循环从0到len-2，此时最高位n-1位的进位</span></span><br><span class="line">            d[len - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// 清0</span></span><br><span class="line">            d[len] =<span class="number">1</span>; <span class="comment">// 高位进1</span></span><br><span class="line">            ++len; <span class="comment">// 总位数+1</span></span><br><span class="line">            ++ans; <span class="comment">// 进位+1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl; <span class="comment">// 输出进位次数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>这段代码将10进制的数字n转换成k进制，存储在d数组，输出的ans是<strong>进位的次数</strong>。</p></blockquote><p>假设输入的 <em>n</em> 是不超过 $2^{62}$ 的正整数，<em>k</em> 都是不超过 10000 的正整数，完成下面的判断题和单选题：</p><p>判断题</p><p>1）若 <em>k</em> &#x3D; 1，则输出 ans 时，len &#x3D; <em>n</em>。（ 错误 ）</p><blockquote><p>n &#x3D; 1, k &#x3D; 1时，len &#x3D; 2。</p><p>i &#x3D; 0：d &#x3D; { 1 }，15行for不满足条件，跳过，22行满足，d &#x3D; { 0, 1 }，len &#x3D; 2，ans &#x3D; 1。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">++d[<span class="number">0</span>]; <span class="comment">// 最后一位加1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + <span class="number">1</span>&lt;len; ++j) &#123; <span class="comment">//for (int j = 0; j + 1 &lt; 1; ++j)，不进入循环</span></span><br><span class="line">    <span class="keyword">if</span> (d[j] == k) &#123; </span><br><span class="line">        d[j] = <span class="number">0</span>; </span><br><span class="line">        d[j + <span class="number">1</span>] += <span class="number">1</span>; </span><br><span class="line">        ++ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[len- <span class="number">1</span>] == k) &#123; <span class="comment">// if (d[0] == 1)，此时d[0]是0</span></span><br><span class="line">    d[len - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// d[0] = 0;</span></span><br><span class="line">    d[len] = <span class="number">1</span>; <span class="comment">// d[1] =1;</span></span><br><span class="line">    ++len; <span class="comment">// len = 2</span></span><br><span class="line">    ++ans; <span class="comment">// ans = 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）若 <em>k</em>&gt;1，则输出 ans 时，len —定小于 <em>n</em>。（ 错误 ）</p><blockquote><p>k &#x3D; 2，n &#x3D; 1 时，转换成二进制数 len &#x3D; 1，不是小于。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">++d[<span class="number">0</span>]; <span class="comment">// 最后一位加1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j + <span class="number">1</span>&lt;len; ++j) &#123; <span class="comment">//for (int j = 0; j + 1 &lt; 1; ++j)，不进入循环</span></span><br><span class="line">    <span class="keyword">if</span> (d[j] == k) &#123; </span><br><span class="line">        d[j] = <span class="number">0</span>; </span><br><span class="line">        d[j + <span class="number">1</span>] += <span class="number">1</span>; </span><br><span class="line">        ++ans; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (d[len- <span class="number">1</span>] == k) &#123; <span class="comment">// if (d[0] == 2)，此时d[0]是1</span></span><br><span class="line">    d[len - <span class="number">1</span>] = <span class="number">0</span>; <span class="comment">// d[0] = 0;</span></span><br><span class="line">    d[len] = <span class="number">1</span>; <span class="comment">// d[1] = 1;</span></span><br><span class="line">    ++len; <span class="comment">// len = 1</span></span><br><span class="line">    ++ans; <span class="comment">// ans = 0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）若 <em>k</em> &gt; 1，则输出 ans 时，$k^{len}$ —定小于 <em>n</em>。（ 正确 ）</p><blockquote><p>n 转化为 len 位的 k 进制数，n的最大值为$k^{len} - 1$，一定小于$k^{len}$。</p></blockquote><p>单选题</p><p>4）若输入的 <em>n</em> 等于：$10^{15}$，输入的 <em>k</em> 为 1，则输出等于（ ）。</p><p>A. 1</p><p>B. $(10^{30} − 10^{15}) \div 2$</p><p>C. $(10^{30} + 10^{15}) \div 2$</p><p>D. $10^{15}$</p><blockquote><p>选D。</p><p>i&#x3D;0,d[0]&#x3D;1，不进入15行for循环，进入22行if，d[0]&#x3D;0,d[1]&#x3D;1, ans&#x3D;1, len&#x3D;2。</p><p>i&#x3D;1,d[0]&#x3D;1，进入15行for循环，j&#x3D;0,进入16行if，d[0]&#x3D;0,d[1]&#x3D;2,ans&#x3D;2。len&#x3D;2,不进入22行if。</p><p>i&#x3D;2，d[0]&#x3D;1，进入15行for循环，j&#x3D;0，进入16行if，d[0]&#x3D;0,d[1]&#x3D;3,ans&#x3D;3。Len&#x3D;2,不进入22行if。</p><p>所以一直是两位数。i每循环一次，ans递增一次。</p></blockquote><p>5）若输入的 <em>n</em> 等于 205, 891, 132, 094, 649（即 $3^{30}$），输入的 <em>k</em> 为 3，则输出等于（ ）。</p><p>A. $3^{30}$</p><p>B. $(3^{30} − 1) \div 2$</p><p>C. $3^{30} − 1$</p><p>D. $(3^{30} + 1) \div 2$</p><blockquote><p>选B。</p></blockquote><p><img src="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230818105631374.png" class="lazyload placeholder" data-srcset="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230818105631374.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818105631374"></p><p>6） 若输入的 <em>n</em> 等于 100, 010, 002, 000, 090，输入的 <em>k</em> 为 10，则输出等于（ ）。</p><p>A. 11, 112, 222, 444, 543</p><p>B. 11,122, 222, 444, 453</p><p>C. 11, 122, 222, 444, 543</p><p>D. 11, 112, 222, 444, 453</p><blockquote><p>选D。</p></blockquote><p><img src="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230818110355743.png" class="lazyload placeholder" data-srcset="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230818110355743.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818110355743"></p><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;                     </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;                                   </span><br><span class="line"><span class="type">int</span> d[<span class="number">50</span>][<span class="number">2</span>]; <span class="comment">//全局变量                 </span></span><br><span class="line"><span class="type">int</span> ans;                                 </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> sum)</span> </span>&#123;               </span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123; <span class="comment">//元素个数为1，求最大值                           </span></span><br><span class="line">        ans = <span class="built_in">max</span>(sum, ans);           </span><br><span class="line">        <span class="keyword">return</span>;                                   </span><br><span class="line">    &#125;                                        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;          </span><br><span class="line">        <span class="type">int</span> a = d[i - <span class="number">1</span>][<span class="number">0</span>], b = d[i - <span class="number">1</span>][<span class="number">1</span>]; <span class="comment">//暂存 d[i-1][0] 和 d[i][1]</span></span><br><span class="line">        <span class="type">int</span> x = d[i][<span class="number">0</span>], y = d[i][<span class="number">1</span>];            </span><br><span class="line">        d[i - <span class="number">1</span>][<span class="number">0</span>] = a + x;  <span class="comment">// d[i - 1][0] = d[i - 1][0] + d[i][0];          </span></span><br><span class="line">        d[i - <span class="number">1</span>][<span class="number">1</span>] = b + y;  <span class="comment">// d[i - 1][1] = d[i - 1][1] + d[i][1];              </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt; n - <span class="number">1</span>; ++j) <span class="comment">//dp[i+1][]到d[n-1]左移一格</span></span><br><span class="line">            d[j][<span class="number">0</span>] = d[j + <span class="number">1</span>][<span class="number">0</span>], d[j][<span class="number">1</span>] = d[j + <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> s = a + x + <span class="built_in">abs</span>(b - y); <span class="comment">//x向加，y相减              </span></span><br><span class="line">        <span class="built_in">dfs</span>(n - <span class="number">1</span>, sum + s); <span class="comment">//递归n-1层              </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n - <span class="number">1</span>; j &gt; i; --j)  <span class="comment">//恢复</span></span><br><span class="line">            d[j][<span class="number">0</span>] = d[j - <span class="number">1</span>][<span class="number">0</span>], d[j][<span class="number">1</span>] = d[j - <span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line">        d[i - <span class="number">1</span>][<span class="number">0</span>] = a, d[i - <span class="number">1</span>][<span class="number">1</span>] = b; <span class="comment">//恢复 </span></span><br><span class="line">        d[i][<span class="number">0</span>] = x, d[i][<span class="number">1</span>] = y;  <span class="comment">//恢复</span></span><br><span class="line">    &#125;                                        </span><br><span class="line">&#125;                                        </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;                             </span><br><span class="line">    cin &gt;&gt; n;                                </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)              </span><br><span class="line">        cin &gt;&gt; d[i][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;++i)</span><br><span class="line">        cin &gt;&gt; d[i][<span class="number">1</span>];</span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(n, <span class="number">0</span>);</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设输入的 <em>n</em> 是不超过 50 的正整数，<code>d[i][0]</code>、<code>d[i][1]</code> 都是不超过 10000 的正整数，完成下面的判断题和单选题：</p><blockquote><p>这段代码是一个求解最大和的问题。它使用了深度优先搜索（DFS）算法来遍历所有可能的路径，并计算每个路径上的数字之和。最后，它返回最大的数字之和作为答案。</p><p>代码的主要逻辑如下：</p><ol><li>首先，定义了一个二维数组 <code>d</code>，用于存储输入的数字对。</li><li>然后，定义了一个全局变量 <code>ans</code>，用于记录最大数字之和。</li><li>接下来，定义了一个递归函数 <code>dfs</code>，用于进行深度优先搜索。该函数接受两个参数：当前的数字对数量 <code>n</code> 和当前的数字之和 <code>sum</code>。</li><li>在 <code>dfs</code> 函数中，首先判断是否到达了基本情况（即只有一个数字对）。如果是，则更新 <code>ans</code> 为当前数字之和和 <code>ans</code> 中的较大值，然后返回。</li><li>如果还有多个数字对，则通过循环遍历每个数字对，并将其与下一个数字对进行合并。合并后的结果存储在 <code>d</code> 数组中。</li><li>在每次合并后，计算新的数字之和 <code>s</code>，并递归调用 <code>dfs</code> 函数，传入更新后的数字对数量 <code>n - 1</code> 和新的</li></ol></blockquote><p>注意21行的<code>int s = a + x + abs(b - y);</code>，x是求和，y是求差。</p><p>判断题</p><p>1）若输入 <em>n</em> 为 0，此程序可能会死循环或发生运行错误。（ 错误）</p><blockquote><p>不进入第10行的<code>if</code> 和 第14行的<code>for</code>，函数运行结束，不会死循环。</p></blockquote><p>2）若输入 <em>n</em> 为 20，接下来的输入全为 0，则输出为 0。（ 正确 ）</p><blockquote><p>一堆0求和，结果还是0。 </p></blockquote><p>3）输出的数一定不小于输入的 <code>d[i][0]</code> 和 <code>d[i][1]</code> 的任意一个。（ 错误 ）</p><blockquote><p>反例：n&#x3D;2,<code>d[0][0]=d[1][0]=1,d[0][1]=d[1][1]=10</code>,输出2。</p></blockquote><p>单选题</p><p>4）若输入的 <em>n</em> 为 20，接下来的输入是 20 个 9 和 20 个 0，则输出为（ ）。</p><p>A. 1890</p><p>B. 1881</p><p>C. 1908</p><p>D. 1917</p><blockquote><p>选B。</p><p>每层递归都合并[0]和[1]，得到最大值。</p><p>$2 \times 9 + 3 \times 9 + 4 \times 9 + … + 20 \times 9 &#x3D; 1881$</p><p>因为<code>d[i][1]=0</code>，所以相当于20个9，每次相邻合并，合并的两个数的和累加，求最大值。</p></blockquote><p>5）若输入的 <em>n</em> 为 30，接下来的输入是 30 个 0 和 30 个 5，则输出为（ ）。</p><p>A. 2000</p><p>B. 2010</p><p>C. 2030</p><p>D. 2020</p><blockquote><p>选C。每层递归都合并[0]和[1]，得到最大值。</p><p>$0 + 5 + 10 + 15 + … + 28 \times 5 &#x3D; 2030$</p></blockquote><p>6）若输入的 <em>n</em> 为 15，接下来的输入是 15 到 1，以及 15 到 1，则输出为（ ）。</p><p>A. 2440</p><p>B. 2220</p><p>C. 2240</p><p>D. 2420</p><blockquote><p>选C。</p></blockquote><p><img src="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230818120945854.png" class="lazyload placeholder" data-srcset="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230818120945854.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818120945854"></p><hr><h1 id="三、完善程序"><a href="#三、完善程序" class="headerlink" title="三、完善程序"></a>三、完善程序</h1><h2 id="3-1-质因数分解"><a href="#3-1-质因数分解" class="headerlink" title="3.1 质因数分解"></a>3.1 质因数分解</h2><p>给出正整数 <em>n</em>，请输出将 <em>n</em> 质因数分解的结果，结果从小到大输出。</p><p>例如：输入 <em>n</em>&#x3D;120，程序应该输出 <code>2 2 2 3 5</code>，表示：120 &#x3D; 2 × 2 × 2 × 3 × 5。输入保证 2 ≤ <em>n</em> ≤ $10^9$。</p><p>提示：先从小到大枚举变量 <em>i</em>，然后用 <em>i</em> 不停试除 <em>n</em> 来寻找所有的质因子。</p><p>试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span>(i = ①<span class="number">2</span>; ②i*i &lt;=n; i ++)&#123; <span class="comment">//用36、7举例</span></span><br><span class="line">        ③<span class="keyword">while</span>(n%i == <span class="number">0</span>) &#123; <span class="comment">//输出所有质因子i</span></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            n = n / i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(④n &gt; <span class="number">1</span>) <span class="comment">//n除到最后，如果等于1，不输出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, ⑤n);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>34、①处应填（ ）</p><p>A. <code>1</code></p><p>B. <code>n-1</code></p><p>C. <code>2</code></p><p>D. <code>0</code></p><blockquote><p>选C。最小的质因数是2，从2开始。</p></blockquote><p>35、②处应填（ ）</p><p>A. <code>n/i</code></p><p>B. <code>n/(i*i)</code></p><p>C. <code>i*i</code></p><p>D. <code>i*i*i</code></p><blockquote><p>选C。常用 i * i。</p></blockquote><p>36、③处应填（ )</p><p>A. <code>if(n%i == 0)</code></p><p>B. <code>if(i*i &lt;= n)</code></p><p>C. <code>while(n%i == 0)</code></p><p>D. <code>while(i*i &lt;= n)</code></p><blockquote><p>选C。<code>if</code>不能输出所有质因子，<code>120 = 2 × 2 × 2 × 3 × 5</code>分解出来有多个2，故用<code>while</code>。</p></blockquote><p>37、④处应填（ ）</p><p>A. <code>n &gt; 1</code></p><p>B. <code>n &lt;= 1</code></p><p>C. <code>i &lt; n / i</code></p><p>D. <code>i + i &lt;= n</code></p><blockquote><p>选A。n除到最后，如果等于1，不输出。</p></blockquote><p>38、⑤处应填（ )</p><p>A. <code>2</code></p><p>B. <code>n/i</code></p><p>C. <code>n</code></p><p>D. <code>i</code></p><blockquote><p>选C。输出n。</p></blockquote><h2 id="3-2-最小区间覆盖"><a href="#3-2-最小区间覆盖" class="headerlink" title="3.2 最小区间覆盖"></a>3.2 最小区间覆盖</h2><p>给出 <em>n</em> 个区间，第 <em>i</em> 个区间的左右端点是 $[a_i, b_i]$。现在要在这些区间中选出若干个，使得区间 $[0, m]$ 被所选区间的并覆盖（即每一个 0 ≤ <em>i</em> ≤ <em>m</em> 都在某个所选的区间中）。保证答案存在，求所选区间个数的最小值。</p><p>输入第一行包含两个整数 <em>n</em> 和 <em>m</em> （1 ≤ <em>n</em> ≤ 5000, 1 ≤ <em>m</em> ≤ $10^9$）</p><p>接下来 <em>n</em> 行，每行两个整数 $a_i, b_i$ （0 ≤ $a_i, b_i$ ≤ <em>m</em>）。</p><p>提示：使用贪心法解决这个问题。先用 <em>O</em>($n^2$) 的时间复杂度排序，然后贪心选择这些区间。</p><p>试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5000</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">segment</span> &#123; <span class="type">int</span> a, b; &#125; A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">()</span> <span class="comment">// 冒泡排序，左端点升序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            <span class="keyword">if</span> (①A[j].a &lt; A[j<span class="number">-1</span>].a) <span class="comment">//如果左侧线段的左端点大，交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                segment t = A[j];</span><br><span class="line">                ②A[j] = A[j<span class="number">-1</span>]; A[j<span class="number">-1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        cin &gt;&gt; A[i].a &gt;&gt; A[i].b;</span><br><span class="line">    <span class="built_in">sort</span>(); <span class="comment">//左端点升序排序</span></span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>; <span class="comment">//处理后的线段个数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) <span class="comment">//其他更大范围的线段</span></span><br><span class="line">        <span class="keyword">if</span> (③A[i].b &gt; A[p<span class="number">-1</span>].b) <span class="comment">//覆盖的线段删除</span></span><br><span class="line">            A[p++] = A[i];</span><br><span class="line">    n = p; <span class="comment">//p是更新后的线段个数</span></span><br><span class="line">    <span class="type">int</span> ans =<span class="number">0</span>, r = <span class="number">0</span>; <span class="comment">//已覆盖区间有边界</span></span><br><span class="line">    <span class="type">int</span> q = <span class="number">0</span>; <span class="comment">//当前线段编号</span></span><br><span class="line">    <span class="keyword">while</span> (r &lt; m) <span class="comment">//已覆盖区间有边界 &lt; m</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (④q+<span class="number">1</span> &lt; n &amp;&amp; A[q+<span class="number">1</span>].a &lt;= r) <span class="comment">//下一线段存在 且 左端点在已覆盖区间右边界左侧</span></span><br><span class="line">            q++; </span><br><span class="line">        ⑤r = <span class="built_in">max</span>(r, A[q].b); <span class="comment">//确定新的已覆盖区间右边界</span></span><br><span class="line">        ans++; <span class="comment">//统计答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>39、①处应填（ ）</p><p>A. <code>A[j].b &gt; A[j-1].b</code><br> B. <code>A[j].a &lt; A[j-1].a</code><br> C. <code>A[j].a &gt; A[j-1].a</code><br> D. <code>A[j].b &lt; A[j-1].b</code></p><blockquote><p>选B。左侧线段的左端点更大，交换。</p></blockquote><p>40、②处应填（ ）</p><p>A. <code>A[j+1] = A[j]; A[j] = t;</code></p><p>B. <code>A[j-1] = A[j]; A[j] = t;</code></p><p>C. <code>A[j] = A[j+1]; A[j+1] = t;</code></p><p>D. <code>A[j] = A[j-1]; A[j-1] = t;</code></p><blockquote><p>选D。两数交换，用t暂存。</p></blockquote><p>41、③处应填（ ）</p><p>A. <code>A[i].b &gt; A[p-1].b</code></p><p>B. <code>A[i].b &lt; A[i-1].b</code></p><p>C. <code>A[i].b &gt; A[i-1].b</code></p><p>D. <code>A[i].b &lt; A[p-1].b</code></p><blockquote><p>选A。被其他更大范围的线段覆盖了，删除掉。</p></blockquote><p><img src="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230818125851449.png" class="lazyload placeholder" data-srcset="/../images/2020CSP-J1%E7%9C%9F%E9%A2%98/image-20230818125851449.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230818125851449"></p><blockquote><p>两条红色线段，被上面一条蓝色线段覆盖了，删除。</p></blockquote><p>42、④处应填（ ）</p><p>A. <code>q+1 &lt; n &amp;&amp; A[q+1].a &lt;= r</code></p><p>B. <code>q+1 &lt; n &amp;&amp; A[q+1].b &lt;= r</code></p><p>C. <code>q &lt; n &amp;&amp; A[q].a &lt;= r</code></p><p>D. <code>q &lt; n &amp;&amp; A[q].b &lt;= r</code></p><blockquote><p>选A。下一线段存在 且 下一线段的左端点 在右边界的左边，区间才能续上。</p></blockquote><p>43、⑤处应填（ ）</p><p>A. <code>r = max(r, A[q+1].b)</code></p><p>B. <code>r = max(r, A[q].b)</code></p><p>C. <code>r = max(r, A[q+1].a)</code></p><p>D. <code>q++</code></p><blockquote><p>选B。取最大值，已覆盖区间的右边界。</p></blockquote><hr><p>参考</p><ul><li><a href="https://ti.luogu.com.cn/problemset/1034">1034 - CSP 2020 入门级第一轮 - 洛谷有题 (luogu.com.cn)</a></li><li><a href="https://www.bilibili.com/video/BV1gW4y1h7SG/?spm_id_from=333.788&vd_source=49e30194f6d5798a1f90d69dad9c0460">2020年CSP-J入门级初赛（第一轮）真题讲解_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2020CSP-J1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTeX常用公式</title>
      <link href="/2023/08/12/LaTeX%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F/"/>
      <url>/2023/08/12/LaTeX%E5%B8%B8%E7%94%A8%E5%85%AC%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h2><p>输入 <code>\\</code> ，用<code>&amp;</code> 可以对齐每行。<br>$$<br>A &#x3D; 10 + 1 \<br> &#x3D; 5 + 5 + 1 \<br>  &#x3D; 5 + 5 + 1 \<br>&amp; &#x3D; 5 + 5 + 1 \<br>&amp; &#x3D; 5 + 5 + 1 \<br>$$</p><h2 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h2><p>_表示下标、^表示上标，但上下标内容不止一个字符时，需用大括号括起来。单引号’表示求导</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line">a<span class="built_in">^</span>&#123;-1&#125;<span class="built_in">_</span>&#123;-2&#125; + b<span class="built_in">^</span>2<span class="built_in">_</span>1 = x&#x27; + x&#x27;&#x27;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$$<br>a^{-1}_{-2} + b^2_1 &#x3D; x’ + x’’<br>$$</p><h2 id="分式"><a href="#分式" class="headerlink" title="分式"></a>分式</h2><p>\frac表示分式</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\frac</span>&#123;10&#125;&#123;20 + 3&#125;</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$$<br>\frac{10}{20 + 3}<br>$$</p><h2 id="积分、极限、求和、乘积"><a href="#积分、极限、求和、乘积" class="headerlink" title="积分、极限、求和、乘积"></a>积分、极限、求和、乘积</h2><p>命令：\int表示积分，\infty无穷大，\lim表示极限， \sum表示求和，\prod表示乘积，^、_表示上、下限</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br><span class="line"><span class="keyword">\int</span><span class="built_in">_</span>&#123;1&#125;<span class="built_in">^</span>&#123;10&#125; x<span class="keyword">\mathrm</span>&#123;d&#125;x </span><br><span class="line">+ <span class="keyword">\lim</span><span class="built_in">_</span>&#123;x <span class="keyword">\to</span> <span class="keyword">\infty</span>&#125;x<span class="built_in">^</span>&#123;10&#125; </span><br><span class="line">+ <span class="keyword">\sum</span><span class="built_in">_</span>&#123;n=1&#125;<span class="built_in">^</span>&#123;30&#125; </span><br><span class="line">+ <span class="keyword">\prod</span><span class="built_in">_</span>&#123;i=2&#125;<span class="built_in">^</span>&#123;30&#125;y<span class="built_in">_</span>i</span><br><span class="line"><span class="built_in">$</span><span class="built_in">$</span></span><br></pre></td></tr></table></figure><p>$$<br>\int_{1}^{10} x\mathrm{d}x + \lim_{x \to \infty}x^{10} + \sum_{n&#x3D;1}^{30} + \prod_{i&#x3D;2}^{30}y_i<br>$$</p><h2 id="向下、上取整"><a href="#向下、上取整" class="headerlink" title="向下、上取整"></a>向下、上取整</h2><p>命令：<code>\lfloor</code>表示左边下取整括号，<code> \rfloor</code>表示右边下取整括号，<code>\lceil</code>表示左边上取整括号，<code>\rceil</code>表示右边上取整括号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$\lfloor x \rfloor$</span><br><span class="line">$\lceil x \rceil$</span><br></pre></td></tr></table></figure><p>$\lfloor x \rfloor$</p><p>$\lceil x \rceil$</p><p>参考文章</p><ul><li><a href="https://zhuanlan.zhihu.com/p/110756681">LaTeX 公式篇 - 知乎 (zhihu.com)</a></li><li><a href="https://blog.csdn.net/qq_36825778/article/details/102584912">Latex——向下取整，向下取整_latex 向下取整_G5Lorenzo的博客-CSDN博客</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> LaTeX </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2021年CSP-J1真题</title>
      <link href="/2023/08/12/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/"/>
      <url>/2023/08/12/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="一、单向选择题"><a href="#一、单向选择题" class="headerlink" title="一、单向选择题"></a>一、单向选择题</h1><p>第 1 题<br>以下不属于面向对象程序设计语言的是（ ）。</p><p>A. C++</p><p>B. Python</p><p>C. Java</p><p>D. C</p><blockquote><p>选D。C语言没有对象，是面向过程语言。</p></blockquote><p>第 2 题<br>以下奖项与计算机领域最相关的是（ ）。</p><p>A. 奥斯卡奖</p><p>B. 图灵奖</p><p>C. 诺贝尔奖</p><p>D. 普利策奖</p><blockquote><p>选B。</p></blockquote><p>第 3 题<br>目前主流的计算机储存数据最终都是转换成（ ）数据进行储存。</p><p>A. 二进制</p><p>B. 十进制</p><p>C. 八进制</p><p>D. 十六进制</p><blockquote><p>选A。</p></blockquote><p>第 4 题<br>以比较作为基本运算，在 N 个数中找出最大数，最坏情况下所需要的最少的比较次数为 （ ）。</p><p><img src="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230812160644484.png" class="lazyload placeholder" data-srcset="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230812160644484.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230812160644484"></p><blockquote><p>选C。第一个数跟第二个数比，大的跟第三个数比，一共比 N - 1 次。</p></blockquote><hr><p>第 5 题<br>对于入栈顺序为 a,b,c,d,e 的序列，下列（ ）不是合法的出栈序列。</p><p> A. a,b,c,d,e</p><p>B. e,d,c,b,a</p><p>C. b,a,c,d,e</p><p>D. c,d,a,e,b</p><blockquote><p>选D。</p></blockquote><div class="mermaid">flowchart LR AA(&quot;出栈顺序      ---​      栈&quot;) --&gt;       A(&quot;      ---​      c​        b        a&quot;) --&gt;|c出栈| B(&quot;c        ---​        b        a&quot;) --&gt;|d入栈| C(&quot;c        ---​        d​        b        a&quot;) --&gt;|d出栈| D(&quot;c d        ---​        b​        a&quot;) --&gt; |a出栈| E(a不在栈顶,错误)</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"> AA(&quot;出栈顺序</span><br><span class="line">      ---</span><br><span class="line">      栈&quot;) --&gt; </span><br><span class="line">      A(&quot;</span><br><span class="line">      ---</span><br><span class="line">      c</span><br><span class="line">        b</span><br><span class="line">        a&quot;) --&gt;|c出栈| B(&quot;c</span><br><span class="line">        ---</span><br><span class="line">        b</span><br><span class="line">        a&quot;) --&gt;|d入栈| C(&quot;c</span><br><span class="line">        ---</span><br><span class="line">        d</span><br><span class="line">        b</span><br><span class="line">        a&quot;) --&gt;|d出栈| D(&quot;c d</span><br><span class="line">        ---</span><br><span class="line">        b</span><br><span class="line">        a&quot;) --&gt; |a出栈| E(a不在栈顶,错误)</span><br></pre></td></tr></table></figure><p>第 6 题<br>对于有 n 个顶点、m 条边的无向连通图 (m&gt;n)，需要删掉（ ）条边才能使其成为一棵树。</p><p> A. n − 1</p><p>B. m − n</p><p>C. m − n − 1</p><p>D. m − n + 1</p><blockquote><p>选D。树有n - 1条边，把这个图变成树，即变成n - 1条边，需要删掉 <code>m - (n - 1) = m - n + 1</code> 条边。</p></blockquote><p>第 7 题<br>二进制数101.11 对应的十进制数是（ ）。</p><p> A. 6.5</p><p>B. 5.5</p><p>C. 5.75</p><p>D. 5.25</p><blockquote><p>选C。</p></blockquote><p>$$<br>1<em>2^2+1</em>2^0+1<em>2^{-1}+1</em>2^{-2} &#x3D; 5.75<br>$$</p><p>第 8 题</p><p>如果一棵二叉树只有根结点，那么这棵二叉树高度为 1。请问高度为 5 的完全二叉树有 （ ）种不同的形态？</p><p>A. 16</p><p>B. 15</p><p>C. 17</p><p>D. 32</p><blockquote><p>A。高度为5，有<code>2^5 = 16</code>个节点，最后一层可以有0~16个节点，有16种形态。</p></blockquote><p>第 9 题<br>表达式 <code>a*(b+c)*d</code> 的后缀表达式为( )，其中<code>*</code>和 <code>+</code>是运算符。</p><p> A. <code>**a+bcd</code></p><p>B.<code> abc+*d*</code></p><p>C. <code>abc+d**</code></p><p>D. <code>*a*+bcd</code></p><blockquote><p>选B。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(b + c) 变成 (b c +) </span><br><span class="line">a * (b c +) 变成 a (b c +) *</span><br><span class="line">a (b c +) * * d 变成 a (b c +) * d *</span><br><span class="line">去掉括号 a b c + * d *</span><br></pre></td></tr></table></figure><p>第 10 题<br>6 个人，两个人组一队，总共组成三队，不区分队伍的编号。不同的组队情况有（ ）种。</p><p>A. 10</p><p>B. 15</p><p>C. 30</p><p>D. 20</p><blockquote><p>选B。6取2，剩下4取2，剩下2取2，队伍没有顺序，要除以三个队伍的排列数。</p></blockquote><p>$$<br>C_6^2 * C^2_4 * C^2_2 &#x2F; A_3^3 &#x3D; 15<br>$$</p><p>第 11 题</p><p>在数据压缩编码中的哈夫曼编码方法，在本质上是一种（ ）的策略。</p><p>A. 枚举</p><p>B. 贪心</p><p> C. 递归</p><p> D. 动态规划</p><blockquote><p>选B。在数据压缩编码中的哈夫曼编码方法，是一种贪心算法，它的基本思想是：在编码过程中，优先选择使编码总长度最短的符号。</p></blockquote><p>第 12 题</p><p>由 1,1,2,2,3 这五个数字组成不同的三位数有（ ）种。</p><p>A. 18 </p><p>B. 15</p><p>C. 12</p><p>D. 24</p><blockquote><p>选A。依次枚举：</p><p>1开头：112、113、121、122、123、131、132</p><p>2开头：211、212、213、221、223、231、232</p><p>3开头：311、312、321、322</p></blockquote><p>第 13 题</p><p>考虑如下递归算法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">solve</span>(n)  </span><br><span class="line">     <span class="keyword">if</span> n&lt;=<span class="number">1</span> <span class="keyword">return</span> <span class="number">1</span>  </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> n&gt;=<span class="number">5</span> <span class="keyword">return</span> n*<span class="built_in">solve</span>(n<span class="number">-2</span>)  </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">return</span> n*<span class="built_in">solve</span>(n<span class="number">-1</span>)  </span><br></pre></td></tr></table></figure><p>则调用 <code>solve(7)</code> 得到的返回结果为（ ）。</p><p>A. 105</p><p>B. 840</p><p>C. 210</p><p>D. 420</p><blockquote><p>选C。7 * 5 * 3 * 2 * 1 &#x3D; 210。</p></blockquote><p>第 14 题</p><p>以 <em>a</em> 为起点，对下边的无向图进行深度优先遍历，则 <em>b</em>,<em>c</em>,<em>d</em>,<em>e</em> 四个点中有可能作为最后一个遍历到的点的个数为（ ）。</p><p><img src="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230827215903496.png" class="lazyload placeholder" data-srcset="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230827215903496.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230827215903496"></p><p>A. 1</p><p>B. 2</p><p>C. 3</p><p>D. 4</p><blockquote><p>选B。b和e可能为最后一个点。</p></blockquote><p>第 15 题</p><p>有四个人要从 A 点坐一条船过河到 B 点，船一开始在 A 点。该船一次最多可坐两个人。 已知这四个人中每个人独自坐船的过河时间分别为 1,2,4,8，且两个人坐船的过河时间为两人独自过河时间的较大者。则最短（ ）时间可以让四个人都过河到 B 点（包括从 B 点把船开回 A 点的时间）。</p><p>A. 14</p><p>B. 15</p><p>C. 16</p><p>D. 17</p><blockquote><p>选B。</p><p>1 号和 2 号过河，花费 2 分钟。</p><p>1 号回来，花费 1 分钟。</p><p>4 号和 8 号过河，花费 8 分钟。</p><p>2 号回来，花费 2 分钟。</p><p>1 号和 2 号再次过河，花费 2 分钟。</p></blockquote><hr><h1 id="二、阅读程序"><a href="#二、阅读程序" class="headerlink" title="二、阅读程序"></a>二、阅读程序</h1><h2 id="（1）"><a href="#（1）" class="headerlink" title="（1）"></a>（1）</h2><p><img src="https://ipic.luogu.com.cn/pu88q.jpg" class="lazyload placeholder" data-srcset="https://ipic.luogu.com.cn/pu88q.jpg" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><blockquote><p>f函数统计1的个数，负数统计补码中1的个数。如下图（2018年考过该算法）</p><p>g函数返回x的最低位（lowbit）。</p></blockquote><p><img src="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230812173934102.png" class="lazyload placeholder" data-srcset="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230812173934102.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230812173934102"></p><p>16.输入的 <em>n</em> 等于 1001 时，程序<strong>不会</strong>发生下标越界。（ 错 ）</p><blockquote><p>a的下标0~999，1001越界。</p></blockquote><p>17.输入的 <em>a</em>[<em>i</em>] 必须全为正整数，否则程序将陷入死循环。（ 错 ）</p><blockquote><p>找一个反例即可，如0、-1。</p></blockquote><p>18.当输入为 <code>5 2 11 9 16 10</code> 时，输出为 <code>3 4 3 17 5</code>。（ 错 ）</p><blockquote><p>输出最后一个数错误，为4。</p></blockquote><p>19.当输入为 <code>1 511998</code> 时，输出为 <code>18</code>。（ 对  ）</p><p>20.将源代码中 <code>g</code> 函数的定义（14∼17 行）移到 main 函数的后面，程序可以正常编译运行。（ 错 ）</p><blockquote><p>前面得声明函数g，才能正常运行。</p></blockquote><p>21.当输入为 <code>2 -65536 2147483647</code> 时，输出为（ B ）。</p><p>A. <code>65532 33</code><br>B. <code>65552 32</code><br>C. <code>65535 34</code><br>D. <code>65554 33</code></p><blockquote><p>65536为2^16。1后面16个0，int32位，补码：1后面16个0不变，前面全变成1，有16个1。</p><p>最低位，1后面16个0。</p><p>65536 + 16 &#x3D; 65552。</p></blockquote><blockquote><p>2147483647是2^31-1，有31个1，最低位为1。</p><p>31 + 1 &#x3D; 32。</p></blockquote><h2 id="（2）"><a href="#（2）" class="headerlink" title="（2）"></a>（2）</h2><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/rddla3oo.png" class="lazyload placeholder" data-srcset="https://cdn.luogu.com.cn/upload/image_hosting/rddla3oo.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p>22、输出的第二行一定是由小写字母、大写字母、数字和 ++、 &#x2F;&#x2F;、&#x3D;&#x3D; 构成的字符串。（ 错 ）</p><blockquote><p>输入编码以外的字符，即大小写字母、数字、+、&#x2F;、&#x3D;，输出乱码。</p></blockquote><p>23、可能存在输入不同，但输出的第二行相同的情形。（  正确 ）</p><p>24、输出的第一行为 -1。（ 正确 ）</p><blockquote><p>char 是 signed char，强转int要补符号位。</p><p>0xff –&gt; 0xffffffff，是-1的补码。</p></blockquote><p>25、设输入字符串长度为 <em>n</em>，<code>decode</code> 函数的时间复杂度为（  ）</p><p>A. <em>O</em>(<em>n</em>)</p><p>B. <em>O</em>(<em>n</em>)</p><p>C. <em>O</em>(<em>n</em>log<em>n</em>)</p><p>D. <em>O</em>(<em>n</em>2)</p><blockquote><p>选B。循环n &#x2F; 4次。</p></blockquote><p>26、当输入为 Y3Nx 时，输出的第二行为（）。</p><p>A. <code>csp</code></p><p>B. <code>csq</code></p><p>C. <code>CSP</code></p><p>D. <code>Csp</code></p><blockquote><p>选B。</p></blockquote><p><img src="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230813180142572.png" class="lazyload placeholder" data-srcset="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230813180142572.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230813180142572"></p><p>27、（3.5 分）当输入为 Y2NmIDIwMjE&#x3D; 时，输出的第二行为（ ）。</p><p>A. <code>ccf2021</code></p><p>B. <code>ccf2022</code></p><p>C. <code>ccf 2021</code></p><p>D. <code>ccf 2022</code></p><blockquote><p>选C。</p></blockquote><p><img src="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230813180359031.png" class="lazyload placeholder" data-srcset="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230813180359031.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230813180359031"></p><p><img src="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230813180711143.png" class="lazyload placeholder" data-srcset="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230813180711143.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230813180711143"></p><h2 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h2><p><img src="https://ipic.luogu.com.cn/yzb73.png" class="lazyload placeholder" data-srcset="https://ipic.luogu.com.cn/yzb73.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"> <img src="https://ipic.luogu.com.cn/sykbe.png" class="lazyload placeholder" data-srcset="https://ipic.luogu.com.cn/sykbe.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="img"></p><p><strong>假设输入的 <em>x</em> 是不超过 1000 的自然数，完成下面的判断题和单选题：</strong></p><blockquote><p>线性筛质数，<a href="https://oi-wiki.org/math/number-theory/sieve/">筛法 - OI Wiki (oi-wiki.org)</a></p></blockquote><p>28、若输入不为 1，把第 13 行删去<strong>不会</strong>影响输出的结果。（ 正确 ）</p><blockquote><p>循环从2开始。</p></blockquote><p>29、第 25 行的 <code>f[i] / c[i * k]</code>可能存在无法整除而向下取整的情况。 （  错误 ）</p><p>30、在执行完 <code>init()</code> 后，<code>f</code> 数组不是单调递增的，但 <code>g</code> 数组是单调递增的。 （ 错误 ）</p><blockquote><p><code>g[i]</code>是i的约数和，如果是质数，则gl]值会较小。比如<code>g[5] = 1+5=6</code>,而<code>g[4] = 1+2+4=7</code>。</p></blockquote><p>31、<code>init</code> 函数的时间复杂度为（  ）。</p><p><img src="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230813181008222.png" class="lazyload placeholder" data-srcset="/../images/2021%E5%B9%B4CSP-J1%E7%9C%9F%E9%A2%98/image-20230813181008222.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230813181008222"></p><blockquote><p>选A。线性筛，复杂度为O(n)。</p></blockquote><p>32、在执行完 <code>init()</code> 后，f*[1],<em>f</em>[2],<em>f</em>[3]…f[100] 中有（  ）个等于 2。</p><p>A. 23</p><p>B. 24</p><p>C. 25</p><p>D. 26</p><blockquote><p>选C。约数只有1和自己，即质数，100以内的质数有25个。</p></blockquote><p>33、（4 分） 当输入为 1000 时，输出为（）。</p><p>A. <code>15 1340</code></p><p>B. <code>15 2340</code></p><p>C. <code>16 2340</code></p><p>D. <code>16 1340</code></p><p>$$<br>1000 &#x3D; 2^3 * 5^3<br>$$</p><blockquote><p> 选C。<code>f[1000] = (1+3)*(1+3)=16</code></p><p>&#96;&#96;g[1000] &#x3D; (1+2+4+8)<em>(1+5+25+125)&#x3D;15</em>156&#x3D;2340&#96;</p></blockquote><hr><h1 id="三、完善程序"><a href="#三、完善程序" class="headerlink" title="三、完善程序"></a>三、完善程序</h1><h2 id="（1）Josephus-问题"><a href="#（1）Josephus-问题" class="headerlink" title="（1）Josephus 问题"></a>（1）Josephus 问题</h2><p>有 <em>n</em> 个人围成一个圈，依次标号 0 至 <em>n</em>−1。从 00 号开始，依次 0,1,0,1,…交替报数，报到 1 的人会离开，直至圈中只剩下一个人。求最后剩下人的编号。</p><p>试补全模拟程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span>;</span><br><span class="line"><span class="type">int</span> F[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, p = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (①) &#123;</span><br><span class="line">        <span class="keyword">if</span>(F[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(②) &#123;</span><br><span class="line">                F[i] =<span class="number">1</span>;</span><br><span class="line">                ③;</span><br><span class="line">            &#125;</span><br><span class="line">            ④;</span><br><span class="line">        &#125;</span><br><span class="line">        ⑤;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (i =<span class="number">0</span>;i &lt; n; i++)</span><br><span class="line">        <span class="keyword">if</span>(F[i] ==<span class="number">0</span>)</span><br><span class="line">            ans = i;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>34、①处应填（ ）<br>A.<code>i &lt; n</code><br>B.<code>c &lt; n</code><br>C.<code>i &lt; n- 1</code><br>D.<code>c &lt; n-1</code></p><blockquote><p>选D。变量c表示离开的人数，假设n为3，c&#x3D;2时就停止，故选<code>c &lt; n - 1</code></p></blockquote><p>35、②处应填（ ）<br>A.<code>i % 2 == 0</code><br>B.<code>i % 2 == 1</code><br>C.<code>p</code><br>D.<code>!p</code></p><blockquote><p>选C。变量p表示报数，报到1就离开，F[i]赋值为1。</p></blockquote><p>36、③处应填（ ）<br>A.<code>i++</code><br>B.<code>i = (i + 1) % n</code><br>C.<code>c++</code><br>D.<code>p ^= 1</code></p><blockquote><p>选C。报到1，离开的人数+1。</p></blockquote><p>37、④处应填（ ）<br>A.<code>i++</code><br>B.<code>i = (i + 1) % n</code><br>C.<code>c++</code><br>D.<code>p ^= 1</code></p><blockquote><p>选D。异或，下一个人报数 从0变1 或 从1变0。如果第i人离开了，报数p不变，故在<code>if(F[i] == 0)</code>内。</p></blockquote><p>38、⑤处应填（ ）<br>A.<code>i++</code><br>B.<code>i = (i + 1) % n</code><br>C.<code>c++</code><br>D.<code>p ^= 1</code></p><blockquote><p>选B。<code>if(F[i] == 0)</code>猜出i为下标。一圈数完后，从第一个人开始，所以要<code>% n</code>。</p></blockquote><hr><h2 id="（2）矩形计数"><a href="#（2）矩形计数" class="headerlink" title="（2）矩形计数"></a>（2）矩形计数</h2><p>平面上有 <em>n</em> 个关键点，求有多少个四条边都和 <em>x</em> 轴或者 <em>y</em> 轴平行的矩形，满足四个顶点都是关键点。给出的关键点可能有重复，但完全重合的矩形只计一 次。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span> &#123;</span><br><span class="line"><span class="type">int</span> x, y, id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">equals</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a.x == b.x &amp;&amp; a.y == b.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(point a, point b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ①;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(point A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; n; j++)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">cmp</span>(A[j], A[j - <span class="number">1</span>])) &#123;</span><br><span class="line">point t = A[j];</span><br><span class="line">A[j] = A[j - <span class="number">1</span>];</span><br><span class="line">A[j- <span class="number">1</span>] = t;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unique</span><span class="params">(point A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    <span class="keyword">if</span>(②)</span><br><span class="line">    A[t++] = A[i];</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(point A[], <span class="type">int</span> n, <span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    point p;</span><br><span class="line">    p.x = x;</span><br><span class="line">    p.y = y;</span><br><span class="line">    p.id = n;</span><br><span class="line">    <span class="type">int</span> a = <span class="number">0</span>, b = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (a &lt; b) &#123;</span><br><span class="line">        <span class="type">int</span> mid = ③;</span><br><span class="line">        <span class="keyword">if</span>(④)</span><br><span class="line">            a = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">equals</span>(A[a], p);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line">point A[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; A[i].× &gt;&gt; A[i].y;</span><br><span class="line">        A[i].id = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(A, n);</span><br><span class="line">    n = <span class="built_in">unique</span>(A, n);</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">    <span class="keyword">if</span> (⑤ &amp;&amp; <span class="built_in">binary_search</span>(A, n, A[i].x, A[j].y) &amp;&amp; </span><br><span class="line">                <span class="built_in">binary_search</span>(A, n, A[j].x,A[i].y)) &#123;</span><br><span class="line">    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>试补全枚举算法。</p><p>39、①处应填 ( )<br>A. <code>a.x != b.x ? a.x &lt; b.x : a.id &lt; b.id</code><br>B. <code>a.x != b.x ? a.x &lt; b.x : a.y &lt; b.y</code><br>C. <code>equals(a, b) ? a.id &lt; b.id : a.x &lt; b.x</code><br>D. <code>equals(a, b) ? a.id &lt; b.id : (a.x != b.x ? a.x &lt; b.x : a.y &lt; b.y)</code></p><blockquote><p>选B。两点比较大小。</p></blockquote><p>40、②处应填 ( )<br>A. <code>i == 0 || cmp(A[i], A[i - 1])</code><br>B. <code>t == 0 || equals(A[i], A[t - 1])</code><br>C. <code>i == 0 || !cmp(A[i], A[i - 1])</code><br>D. <code>t == 0 || !equals(A[i], A[t - 1])</code></p><blockquote><p>选D。去重，双指针。</p></blockquote><p>41、③处应填 ( )<br>A. <code>b - (b - a) / 2 + 1</code><br>B. <code>a + (b + 1) &gt;&gt; 1</code><br>C. <code>(a + b) &gt;&gt; 1</code><br>D. <code>a + (b - a + 1) / 2</code></p><blockquote><p>选C。二分。</p></blockquote><p>42、④处应填 ( )<br>A. <code>!cmp(A[mid], p)</code><br>B. <code>cmp(A[mid], p)</code><br>C. <code>cmp(p, A[mid])</code><br>D. <code>!cmp(p, A[mid])</code></p><blockquote><p>选B。<code>A[mid] &lt; p</code>，<code>A[mid] &lt;= p</code>错误，故39题不能选D。</p></blockquote><p>43、⑤处应填 ( )<br>A. <code>A[i].x == A[j].x</code><br>B. <code>A[i].id &lt; A[j].id</code><br>C. <code>A[i].x == A[j].x &amp;&amp; A[i].id &lt; A[j].id</code><br>D. <code>A[i].x &lt; A[j].x &amp;&amp; A[i].y &lt; A[j].y</code></p><blockquote><p>选D。</p></blockquote><hr><p>参考网站视频</p><ul><li><a href="https://ti.luogu.com.cn/problemset/1036">1036 - CSP 2021 入门级第一轮 - 洛谷有题 (luogu.com.cn)</a></li><li><a href="https://www.bilibili.com/video/BV1tg411k7YH/?spm_id_from=333.788&vd_source=49e30194f6d5798a1f90d69dad9c0460">2021年CSP-J入门级初赛(第一轮)真题讲解_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2021CSP-J1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第1章 计算机网络概述</title>
      <link href="/2023/08/12/%E7%AC%AC1%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"/>
      <url>/2023/08/12/%E7%AC%AC1%E7%AB%A0%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>网络可以干什么？</p><ul><li><p>网络通讯（微信、QQ）</p></li><li><p>浏览网站（B站）</p></li><li><p>网络游戏（LOL、王者）</p></li><li><p>等等</p></li></ul><h1 id="一、什么是Internet"><a href="#一、什么是Internet" class="headerlink" title="一、什么是Internet ?"></a>一、什么是Internet ?</h1><p>通俗点，就是一堆网络通过网络互联设备（路由器）连在一起。</p><p>从具体构成角度看：</p><ul><li>节点<ul><li>主机及其上运行的应用程序</li><li>路由器、交换机等网络交换设备</li></ul></li><li>边：通信链路<ul><li>接入网链路：主机连接到互联网的链路</li><li>主干链路：路由器间的链路</li></ul></li><li>协议：控制发送、接收信息<ul><li>如TCP、IP、HTTP、FTP、PPP</li></ul></li></ul><p>从服务角度看：</p><ul><li>使用通信设施进行通信的<strong>分布式应用</strong><ul><li>Web、VoIP、email、分布式游戏、电子商务、社交网络</li></ul></li><li>通信基础设施为<strong>apps</strong>提供编程接口(通信服务）<ul><li>将发送和接收数据的apps与互联网连接起来</li><li>为app应用提供服务选择，类似于邮政服务：<ul><li>无连接不可靠服务</li><li>面向连接的可靠服务</li></ul></li></ul></li></ul><hr><h1 id="二、什么是协议？"><a href="#二、什么是协议？" class="headerlink" title="二、什么是协议？"></a>二、什么是协议？</h1><p>支撑互联网工作的<strong>标准</strong>。</p><p>协议：对等层实体在通信过程中应该遵守的规则和集合。</p><p>![image-20230830172212388](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230830172212388.png)</p><p>网络协议： </p><ul><li>类似人类协议</li><li>机器之间的协议而非人与人之间的协议</li><li>Internet 中所有的通信行为都受协议制约</li></ul><blockquote><p>协议定义了在两个或多个通信实体之间交换的<strong>报文格式</strong>和<strong>次序</strong>，以及在报文传输和&#x2F;或接收或其他事件方面所采取的<strong>动作</strong></p></blockquote><hr><h1 id="三、网络结构的三个部分"><a href="#三、网络结构的三个部分" class="headerlink" title="三、网络结构的三个部分"></a>三、网络结构的三个部分</h1><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><ul><li>主机</li><li>应用程序（客户端和服务器）</li></ul><p>结构</p><ul><li>端系统(主机）：<ul><li>运行应用程序</li><li>如Web、email</li><li>在“网络的边缘”</li></ul></li><li>客户&#x2F;服务器模式（C&#x2F;S）<ul><li>客户端向服务器请求、接收服务</li><li>如Web浏览器&#x2F;服务器；email客户端&#x2F;服务器</li></ul></li><li>对等（peer-peer）模式<ul><li>很少(甚至没有）专门的服务器</li><li>如 Gnutella、KaZaA、Emule</li></ul></li></ul><hr><h3 id="采用网络设施的面向连接服务"><a href="#采用网络设施的面向连接服务" class="headerlink" title="采用网络设施的面向连接服务"></a>采用网络设施的面向连接服务</h3><p>目标:在端系统之间传输数据</p><ul><li>握手：在数据传输之前做好准备<ul><li>人类协议中：你好、你好</li><li>两个通信主机之间为<strong>连接</strong>建立状态</li></ul></li><li>TCP-传输控制协议(Transmission Control Protocol )<ul><li>Internet上面向连接的服务</li></ul></li></ul><p>TCP 服务 </p><ul><li>可靠地、按顺序地传送数据<ul><li>确认和重传</li></ul></li><li>流量控制<ul><li>发送方不会淹没接收方</li></ul></li><li>拥塞控制<ul><li>当网络拥塞时，发送方降低发送速率</li></ul></li></ul><h3 id="采用基础设施的无连接服务"><a href="#采用基础设施的无连接服务" class="headerlink" title="采用基础设施的无连接服务"></a>采用基础设施的无连接服务</h3><p>目标:在端系统之间传输数据</p><ul><li>无连接服务</li><li>UDP-用户数据报协议(User Datagram Protocol)RFC 768:<ul><li>无连接</li><li>不可靠数据传输</li><li>无流量控制</li><li>无拥塞控制</li></ul></li></ul><hr><p>使用TCP的应用：</p><ul><li>HTTP(Web),FTP(文件传送),Telnet(远程登录），SMTP (email)</li></ul><p>使用UDP的应用：</p><ul><li>流媒体、远程会议、DNS、Internet电话</li></ul><hr><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><ul><li>网络核心：路由器的网状网络</li><li>基本问题：数据怎样通过网络进行输？<ul><li><strong>电路交换</strong>：为每个呼叫预留一条专有电路：如电话网</li><li><strong>分组交换</strong>：<ul><li>将要传送的数据分成一个个单位：分组</li><li>将分组从一个路由器传到相邻路由器(<strong>hop</strong>），一段段最终从源端传到目标端</li><li>每段：采用链路的最大传输能力(带宽）</li></ul></li></ul></li></ul><p>网络分类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph TB</span><br><span class="line">通信网络 --&gt; 电路交换网络 --&gt; FDM &amp; TDM</span><br><span class="line">通信网络 --&gt; 分组交换网络 --&gt; 虚电路网络 &amp; 数据包网络</span><br></pre></td></tr></table></figure><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p> 端到端的资源被分配给从源端到目标端的呼叫 “call”：</p><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812112859334.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812112859334.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230812112859334"></p><ul><li><p>图中，每段链路有4条线路： </p><ul><li>该呼叫采用了上面链路的第2个线路，右边链路的第1个线路（piece）</li></ul></li><li><p>独享资源：不同享</p><ul><li>每个呼叫一旦建立起来就能够保证性能</li></ul></li><li><p>如果呼叫没有数据发送，被分配的资源就会被浪费 (no sharing)</p></li><li><p>通常被传统电话网络采用</p></li></ul><p>为呼叫预留端-端资源</p><ul><li>链路带宽、交换能力</li><li>专用资源：不共享</li><li>保证性能</li><li>要求建立呼叫连接</li></ul><p>网络资源（如带宽）被分成片</p><ul><li>为呼叫分配<strong>片</strong></li><li>如果某个呼叫没有数据，则其资源片处于<strong>空闲状态</strong>（不共享）</li><li>将带宽分成片<ul><li>频分(Frequencydivision multiplexing) </li><li>时分(Time-division multiplexing) </li><li>波分(Wave-divis）</li><li>码分(CDM)</li></ul></li></ul><p>计算举例</p><ul><li>在一个电路交换网络上，从主机A到主机B发送一个640,000比特的文件需要多长时间？ <ul><li>所有的链路速率为1.536 Mbps </li><li>每条链路使用时隙数为24的TDM</li><li>建立端-端的电路需500 ms</li></ul></li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">每条链路的速率（一个时间片）：1.536Mbps/24 = 64kbps</span><br><span class="line">传输时间：640kb/64kps = 10s</span><br><span class="line">共用时间：传输时间+建立链路时间=10s + 500ms = 10.5s</span><br></pre></td></tr></table></figure><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812114957016.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812114957016.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230812114957016"></p><p>以<strong>分组</strong>为单位存储-转发方式</p><ul><li>网络带宽资源不再分分为一个个片，传输时使用全部带宽</li><li>主机之间传输的数据被分为一个个分组</li></ul><p><strong>资源共享</strong>，按需使用：</p><ul><li>存储-转发：分组每次移动一跳（ hop ） </li><li>在转发之前，节点必须收到整个分组 <ul><li>延迟比线路交换要大 </li><li>排队时间</li></ul></li></ul><p>存储-转发</p><ul><li>被传输到下一个链路之前，整个分组必须到达路由器：<strong>存储-转发</strong></li><li>在一个速率为R bps的链路，一个长度为L bits 的分组的存储转发延时： L&#x2F;R s</li></ul><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812121522155.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812121522155.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230812121522155"></p><p>排队和延迟： </p><ul><li>如果到达速率 &gt; 链路的输出速率: <ul><li>分组将会排队，等待传输 </li><li>如果路由器的缓存用完了，分组将会被抛弃</li></ul></li></ul><p>关键功能</p><ul><li><strong>路由</strong>: 决定分组采用的源到 目标的路径 <ul><li>路由算法</li></ul></li><li><strong>转发</strong>: 将分组从路由器的输 入链路转移到输出链路</li></ul><p>统计多路复用</p><h3 id="分组交换-vs-电路交换"><a href="#分组交换-vs-电路交换" class="headerlink" title="分组交换 vs. 电路交换"></a>分组交换 vs. 电路交换</h3><p>同样的网络资源，分组交换允许更多用户使用网络！</p><p>1 Mb&#x2F;s 链路，每个用户活动时100 kb&#x2F;s，只有10% 的时间是活动的。 </p><ul><li>电路交换： 最多10 用户。$ \dfrac{1Mb&#x2F;s}{100kb&#x2F;s} $</li></ul><p>$$<br>每个用户分配100kb&#x2F;s，最多有\dfrac{1Mb&#x2F;s}{100kb&#x2F;s} &#x3D; 10 个用户<br>$$</p><ul><li>分组交换：</li></ul><p>$$<br>35 用户时 ，&gt;&#x3D;10个用户活动的概率为 1 - \sum_{n&#x3D;0}^{9} C^{35}_n P^n(1-P)^{35-n} &#x3D; 0.0004<br>$$</p><p>分组交换是“突发数据的胜利者？”</p><ul><li><p>适合于对突发式数据传输 </p><ul><li><p>资源共享 </p></li><li><p>简单，不必建立呼叫</p></li></ul></li><li><p>过度使用会造成网络拥塞：分组延时和丢失 </p><ul><li>对可靠地数据传输需要协议来约束：拥塞控制</li></ul></li><li><p>Q: 怎样提供类似电路交换的服务？ </p><ul><li>保证音频&#x2F;视频应用需要的带宽 </li><li>一个仍未解决的问题(chapter 7)</li></ul></li></ul><p>分组交换网络：存储-转发</p><p> 分组交换: 分组的存储转发一段一段从源端传到目标端 ，按照有无网络层的连接，分成： </p><ol><li><p><strong>数据报</strong>网络： (datagram)</p><ul><li>分组的目标地址决定下一跳 </li><li>在不同的阶段，路由可以改变 </li><li>类似：送快递、寄信（有目标地址，路由就是快递站、邮局）</li><li>工作原理<ul><li>在通信之前,无须建立起一个连接,有数据就传输 </li><li>每一个分组都独立路由(路径不一样,可能会失序) </li><li>路由器根据分组的目标地址进行路由</li></ul></li></ul><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812211759473.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812211759473.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="数据包网络"></p></li><li><p><strong>虚电路</strong>网络： (virtual circuit)</p><ul><li>每个分组都带标签（虚电路标识 VC ID），标签决定下一跳 </li><li>在<strong>呼叫建立</strong>时决定路径，在整个呼叫中路径保持不变 </li><li>路由器维持<strong>每个呼叫的状态信息</strong> </li><li>类似：打电话（建立连接后，通信）</li><li>X.25 和ATM</li></ul></li></ol><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812212123051.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230812212123051.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="虚电路"></p><p>虚电路是<strong>有连接</strong>的，连接<strong>不仅</strong>体现在源主机和目标主机上，还体现在<strong>中间经过的所有节点</strong>上。</p><p>TCP是<strong>面向连接</strong>，连接<strong>仅</strong>体现在<strong>源主机和目标主机上</strong>，中间的路由器<strong>不维护</strong>通信状态。</p><hr><h2 id="接入网、物理媒体"><a href="#接入网、物理媒体" class="headerlink" title="接入网、物理媒体"></a>接入网、物理媒体</h2><ul><li>有线或无线通信链路</li></ul><h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p>住宅接入：modem</p><ul><li>将上网数据<strong>调制</strong>加载音频信号上，在电话线上传输，在局端将其中的数据<strong>解调</strong>出来；反之亦然 <ul><li>调频 </li><li>调幅 </li><li>调相位 </li><li>综合调制</li></ul></li><li>拨号<strong>调制解调器</strong> <ul><li><strong>56Kbps</strong> 的速率直接接入路由器(通常更低) </li><li>不能同时上网和打电话：不能总是在线</li></ul></li></ul><p>接入网: digital subscriber line (DSL) </p><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814110144217.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814110144217.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="接入网"></p><ul><li>采用<strong>现存的</strong>到交换局DSLAM的电话线 <ul><li>DSL线路上的数据被传到互联网 </li><li>DSL线路上的语音被传到电话网</li></ul></li><li>&lt; 2.5 Mbps上行传输速率(typically &lt; 1 Mbps) </li><li>&lt; 24 Mbps下行传输速率(typically &lt; 10 Mbps)</li><li>特点<ul><li>打电话时，可以上网</li><li>上行和下行带宽<strong>独享</strong></li></ul></li></ul><p>线缆网络</p><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814111009767.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814111009767.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814111009767"></p><ul><li><p>有线电视信号线缆双向改造 </p></li><li><p>FDM: 在不同频段传输不同信道的数据， 数字电视和上网数据（上下行）</p></li><li><p>HFC: hybrid fiber coax </p><ul><li>非对称: 最高30Mbps的下行传输速率, 2 Mbps 上行传输 速率</li></ul></li><li><p>线缆和光纤网络将个家庭用户接入到 ISP 路由器 </p></li><li><p>各用户<strong>共享</strong>到线缆头端的接入网络 </p><ul><li>与DSL不同, DSL每个用户一个专用线路到CO（central  office）、</li></ul></li><li><p>特点</p><ul><li>上行带宽<strong>共享</strong></li></ul></li></ul><p>电缆模式</p><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814111805679.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814111805679.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814111805679"></p><p>家庭网络</p><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814112016161.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814112016161.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814112016161"></p><p>企业接入网络(Ethernet)</p><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814112305955.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814112305955.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814112305955"></p><ul><li>经常被企业或者大学等机构采用 <ul><li>10 Mbps, 100Mbps, 1Gbps, 10Gbps传输率 </li><li>现在，端系统经常直接接到以太网络交换机上</li></ul></li></ul><p>无线接入网络</p><ul><li>各无线端系统共享无线接入网络（端系统到无线路由器） <ul><li>通过基站或者叫接入点</li></ul></li></ul><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814112718387.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814112718387.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814112718387"></p><h3 id="物理媒体"><a href="#物理媒体" class="headerlink" title="物理媒体"></a>物理媒体</h3><ul><li><strong>Bit</strong>: 在发送-接收对间传播 </li><li>物理链路：连接每个发送-接 收对之间的物理媒体 </li><li>导引型媒体: <ul><li>信号沿着固体媒介被导引：同轴电缆、光纤、 双绞线</li></ul></li><li>非导引型媒体： <ul><li>开放的空间传输电磁波或者光信号，在电磁或者光信号中承 载数字数据</li></ul></li></ul><p>双绞线 (TP) </p><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814114355509.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814114355509.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814114355509"></p><ul><li>两根绝缘铜导线拧合 <ul><li>5类：100Mbps 以太网 ，Gbps 千兆位以太网 </li><li>6类：10Gbps万兆以太网</li></ul></li></ul><p>同轴电缆： </p><p><img src="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814115317990.png" class="lazyload placeholder" data-srcset="/../images/1-%E4%BB%80%E4%B9%88%E6%98%AFInternet/image-20230814115317990.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230814115317990"></p><ul><li>两根同轴的铜导线 </li><li>双向 </li><li>基带电缆： <ul><li>电缆上一个单个信道 </li><li>Ethernet</li></ul></li><li>宽带电缆： <ul><li>电缆上有多个信道 </li><li>HFC</li></ul></li></ul><p>光纤和光缆： </p><ul><li>光脉冲，每个脉冲表示一个 bit，在玻璃纤维中传输 </li><li>高速： <ul><li>点到点的高速传输（如10  Gps-100Gbps传输速率 ）</li></ul></li><li>低误码率：在两个中继器之 间可以有很长的距离，不受 电磁噪声的干扰 </li><li>安全</li></ul><p>无线链路</p><p>开放空间传输电磁波，携带要传输的数据 </p><ul><li>无需物理“线缆” </li><li>双向 </li><li>传播环境效应： <ul><li>反射 </li><li>吸收 </li><li>干扰</li></ul></li></ul><p>无线链路类型: </p><ul><li>地面微波  e.g. up to 45 Mbps channels </li><li>LAN (e.g., WiFi) <ul><li>11Mbps, 54 Mbps,540Mbps…</li></ul></li><li>wide-area (e.g., 蜂窝) <ul><li>3G cellular: ~ 几Mbps </li><li>4G 10Mbps </li><li>5G 数Gbps</li></ul></li><li>卫星<ul><li>每个信道Kbps 到45Mbps (或者 多个聚集信道) </li><li>270 msec端到端延迟 </li><li>同步静止卫星和低轨卫星</li></ul></li></ul><hr><h1 id="四、Internet-ISP结构"><a href="#四、Internet-ISP结构" class="headerlink" title="四、Internet&#x2F;ISP结构"></a>四、Internet&#x2F;ISP结构</h1><p>互联网络结构：网络的网络 </p><ul><li>端系统通过<strong>接入ISPs</strong> (Internet Service Providers)连接到互联网 <ul><li>住宅，公司和大学的ISPs</li></ul></li><li>接入ISPs相应的必须是互联的 <ul><li>因此任何2个端系统可相互发送分组到对方</li></ul></li><li>导致的“网络的网络”非常复杂 <ul><li>发展和演化是通过<strong>经济的</strong>和<strong>国家的</strong>政策来驱动的</li></ul></li></ul><p>![image-20230814161522462](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230814161522462.png)</p><p>在网络的最中心，一些为数不多的充分连接的大范围网络（分布广、节点有限、 但是之间有着多重连接） </p><ul><li>“tier-1” commercial ISPs (e.g., Level 3, Sprint, AT&amp;T, NTT), 国家或者国际范围的覆盖 </li><li>content provider network (e.g., Google): 将它们的数据中心接入ISP，方便周边用户的访问；通常私有网络之间用专网绕过第一层ISP和区域ISPs</li></ul><h2 id="三层-ISP"><a href="#三层-ISP" class="headerlink" title="三层 ISP"></a>三层 ISP</h2><ul><li><p><strong>中心：第一层ISP</strong>（如UUNet, BBN&#x2F;Genuity, Sprint,  AT&amp;T）<strong>国家&#x2F;国际覆盖</strong>，带宽很宽，速率极高 </p><ul><li><p>直接与其他第一层ISP相连，通过<code>peer</code>或<code>IXP</code>连接</p></li><li><p>与大量的第二层ISP和其他客户网络相连</p></li><li><p>松散的层次模型</p><p>![第一层ISP](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230814162008198.png)</p></li></ul></li><li><p><strong>第二层ISP</strong>: 更小些的 (通常是<strong>区域性</strong>的) ISP </p><ul><li><p>接入一个或多个第一层ISPs，也可能接入其他第二层ISP</p><p>![第二层ISP](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230814162354306.png)</p></li></ul></li><li><p><strong>第三层ISP</strong>与其他本地ISP </p><ul><li><p>接入网 (与端系统最近)</p><p>![第三层ISP](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230814162519920.png)</p></li></ul><p>端系统：一个分组要经过许多网络！</p><p>![image-20230814162801285](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230814162801285.png)</p></li><li><p>很多内容提供商(如：Google, Akamai )可能会部署自己的网络,连接自己的在各地的DC（数据中心），走自己的数据 </p></li><li><p>连接若干local ISP和各级（包括一层）ISP,更加靠近用户</p></li></ul><h2 id="ISP之间的连接"><a href="#ISP之间的连接" class="headerlink" title="ISP之间的连接"></a>ISP之间的连接</h2><ul><li>POP: 高层ISP面向客户网络的接入点，涉及费用结算 <ul><li>如一个低层ISP接入多个高层ISP，多宿（multi home）</li></ul></li><li>对等接入：2个ISP对等互接，不涉及费用结算 </li><li>IXP：多个对等ISP互联互通之处，通常不涉及费用结算 <ul><li>对等接入</li></ul></li><li>ICP自己部署专用网络，同时和各级ISP连接</li></ul><hr><h1 id="五、性能"><a href="#五、性能" class="headerlink" title="五、性能"></a>五、性能</h1><h2 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h2><p>在路由器缓冲区的分组队列 </p><ul><li>分组<strong>到达链路的速率</strong>超过了<strong>链路输出</strong>的能力 </li><li>分组等待排到队头、被传输</li></ul><p>![分组延时和丢失](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230815103859909.png)</p><p>四种分组延时 </p><ol><li><p>节点处理延时： </p><ul><li><p>检查 bit级差错 </p></li><li><p>检查分组首部和决定将分组导向何处</p></li></ul></li><li><p>排队延时 </p><ul><li>输出链路上等待传输的 时间 </li><li>依赖于路由器的拥塞程</li></ul></li><li><p>传输延时: </p><ul><li>R&#x3D;链路带宽(bps) </li><li>L&#x3D;分组长度(bits) </li><li>将分组发送到链路上的 时间&#x3D; L&#x2F;R </li><li>存储转发延时</li></ul></li><li><p>传播延时: </p><ul><li>d &#x3D; 物理链路的长度 </li><li>s &#x3D; 在媒体上的传播速度 (~2x108 m&#x2F;sec) </li><li>传播延时 &#x3D; d&#x2F;s</li></ul></li></ol><p>R&#x3D;链路带宽 (bps) ，L&#x3D;分组长度 (bits) ，a&#x3D;分组到达队列的平均速率 </p><p>**流量强度 &#x3D; **$\frac{L \times a}R$ </p><ul><li>La&#x2F;R ~ 0: 平均排队延时很小 </li><li>La&#x2F;R -&gt; 1: 延时变得很大 </li><li>La&#x2F;R &gt; 1: 比特到达队列的速率超过了从该队 列输出的速率，平均排队延时将趋向无穷大！</li></ul><p>&#x3D;&#x3D;设计系统时流量强度不能大于1！&#x3D;&#x3D;</p><h2 id="分组丢失"><a href="#分组丢失" class="headerlink" title="分组丢失"></a>分组丢失</h2><ul><li><p>链路的队列缓冲区容量有限 </p></li><li><p>当分组到达一个满的队列时，该分组将会丢失 </p></li><li><p>丢失的分组可能会被被前一个节点或源端系统重传，或根本不重传</p></li></ul><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p> 吞吐量: 在源端和目标端之间传输的速率（数 据量&#x2F;单位时间） </p><ul><li><strong>瞬间</strong>吞吐量: 在一个时间点的速率 </li><li><strong>平均</strong>吞吐量: 在一个长时间内平均值</li></ul><p>![吞吐量](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230815115652346.png)</p><p>瓶颈链路：端到端路径上，限制端到端吞吐的链路</p><ul><li><p>其他节点都不传输，一端为$R_s$，另一端为$R_c$，平均吞吐量为min{$R_s$, $R_c$}，瓶颈在小的一端。</p></li><li><p>端到端平均吞吐 &#x3D; min{ $R_1$，$R_2$ , …, $R_n$ }</p></li></ul><p>互联网场景</p><p>![互联网场景](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230815120359975.png)</p><ul><li>链路上的每一段实际可用带宽$R_i$’ &#x3D; ? 端到端吞吐量： min{ $R_i’$ } ?</li><li>每个连接上的端到端吞吐:  min($R_c$ , $R_s$ , $R \div 10$) </li><li>实际上: $R_c$ 或者 $R_s$ 经常是瓶颈</li></ul><hr><h1 id="六、协议层次、服务模型"><a href="#六、协议层次、服务模型" class="headerlink" title="六、协议层次、服务模型"></a>六、协议层次、服务模型</h1><h2 id="协议层次"><a href="#协议层次" class="headerlink" title="协议层次"></a>协议层次</h2><p>网络是一个复杂的系统!  </p><ul><li>网络功能繁杂：数字信号的物理信号承载、点到点、路由、rdt、进 程区分、应用等 </li><li>现实来看，网络的许多构成元素和 设备: <ul><li>主机 </li><li>路由器 </li><li>各种媒体的链路 </li><li>应用 </li><li>协议 </li><li>硬件, 软件</li></ul></li></ul><p><strong>层次化方式</strong>实现复杂网络功能: </p><ul><li>将网络复杂的功能分层功能明确的<strong>层次</strong>，每一层实现了其中一个或一 组<strong>功能</strong>，功能中有其上层可以使用的功能：<strong>服务</strong> </li><li>本层协议实体相互交互执行本层的<strong>协议动作</strong>，目的是实现本层功能， 通过接口为上层提供更好的服务 </li><li>在实现本层协议的时候，直接利用了<strong>下层所提供的服务</strong> </li><li>本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功 能（上层可以利用的）+更下层所提供的服务</li></ul><p>服务和服务访问点 </p><ul><li>服务( Service)：<strong>低层</strong>实体向<strong>上层</strong>实体提供它们之间的<strong>通信</strong>的能力 <ul><li>服务用户(service user) </li><li>服务提供者(service provider )</li></ul></li><li>原语(primitive)：上层使用下层服务的形式，高层使用低层提供的服务，以及低层向高层提供服务都是通过服务访问<strong>原语</strong>来进行<strong>交互</strong>的—形式 </li><li>服务访问点 SAP (Services Access Point) ：上层 使用下层提供的服务通过层间的<strong>接口</strong>—地点； <ul><li>例子:邮箱 </li><li>地址(address)：下层的一个实体支撑着上层的多个实体， SAP有标志不同上层实体的作用 </li><li>可以有不同的实现，队列 </li><li>例子:传输层的SAP: 端口(port)</li></ul></li></ul><p>服务的类型</p><ul><li>面向连接的服务</li><li>面向无连接的服务</li></ul><p>服务和协议 </p><ul><li>服务与协议的区别 <ul><li>服务(Service)：<strong>低层</strong>实体向<strong>上层</strong>实体提供它们之间的通信的能力，是通过原语(primitive)来操作的，<strong>垂直</strong></li><li>协议(protocol) ：<strong>对等层</strong>实体(peer entity)之间在相互通信的过程中，需要遵循的规则的集合，<strong>水平</strong></li></ul></li><li>服务与协议的联系 <ul><li>本层<strong>协议的实现</strong>要靠下层提供的服务来实现 </li><li>本层实体通过协议为上层<strong>提供更高级的服务</strong></li></ul></li></ul><p>数据单元(DU)</p><p>![image-20230816120750303](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230816120750303.png)</p><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><table><thead><tr><th align="center">分层结构</th></tr></thead><tbody><tr><td align="center">应用层</td></tr><tr><td align="center">传输层</td></tr><tr><td align="center">网络层</td></tr><tr><td align="center">链路层</td></tr><tr><td align="center">物理层</td></tr></tbody></table><ul><li>应用层: 网络应用 <ul><li>为人类用户或者其他应用进程提供网络应用服务 </li><li>FTP, SMTP, HTTP,DNS</li></ul></li><li>传输层: 主机之间的数据传输 <ul><li>在网络层提供的端到端通信基础上，细分为进程到进程，将不可靠的通信变成可靠地通信 </li><li>TCP, UDP</li></ul></li><li>网络层: 为数据报从源到目的选择路由 <ul><li>主机主机之间的通信，端到端通信，不可靠 </li><li>IP, 路由协议</li></ul></li><li>链路层: 相邻网络节点间的数据传输 <ul><li>2个相邻2点的通信，点到点通信，可靠或不可靠 </li><li>点对对协议PPP, 802.11(wifi), Ethernet</li></ul></li><li>物理层: 在线路上传送bit</li></ul><p>每一层实现一个特定的功能，上一层借助于下一层提供的服务，通过跟对等层的协议实体，相互交换协议的报文，向上层提供更好的服务。</p><ul><li>物理层把物理介质的<strong>01信号</strong>变成<strong>电磁波</strong>，发送和接收电磁波信号。</li><li>链路层，相邻两点传输以<strong>帧</strong>为单位的数据，实现了了<strong>点到点</strong>的功能。</li><li>网络层在链路层提供的点到点服务的基础上，实现了<strong>源主机</strong>到<strong>目标主机</strong>之间的数据传输，实现了<strong>端到端</strong>的功能。</li><li>传输层加强和细分了网络层的服务，把<strong>主机</strong>之间的传输变成了<strong>进程</strong>之间的传输，解决了网络层<strong>传输不可靠</strong>的问题。</li><li>应用层借助于传输层提供的服务，交换<strong>应用报文</strong>，实现各种各样的网络应用。</li></ul><table><thead><tr><th align="center">ISO&#x2F;OSI 参考模型</th></tr></thead><tbody><tr><td align="center">应用层</td></tr><tr><td align="center">表示层</td></tr><tr><td align="center">会话层</td></tr><tr><td align="center">传输层</td></tr><tr><td align="center">网络层</td></tr><tr><td align="center">链路层</td></tr><tr><td align="center">物理层</td></tr></tbody></table><ul><li>表示层: 允许应用解释传输的数据, e.g., 加密，压缩，机 器相关的表示转换 </li><li>会话层: 数据交换的同步，检查点，恢复 </li><li>互联网协议栈没有这两层! <ul><li>这些服务，如果需要的话，必须被<strong>应用程序</strong>实现</li></ul></li></ul><p>![封装和解封装](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230816154727523.png)</p><p>各层次的协议数据单元 </p><ul><li>应用层：报文(message) </li><li>传输层：报文段(segment)：TCP段，UDP数据报 </li><li>网络层：分组packet（如果无连接方式：数据报 datagram） </li><li>数据链路层：帧(frame) </li><li>物理层：位(bit)</li></ul><hr><h1 id="七、历史"><a href="#七、历史" class="headerlink" title="七、历史"></a>七、历史</h1><p>![image-20230816164241892](..&#x2F;images&#x2F;第1章 计算机网络概述&#x2F;image-20230816164241892.png)</p><hr><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>组成角度看什么是互联网 </p><ul><li><p>边缘：端系统（包括应用）+ 接入网 </p></li><li><p>核心：网络交换设备+通信链路 </p></li><li><p>协议：对等层实体通信过程中遵守的规则的集合 </p><ul><li>语法，语义，时序</li></ul></li></ul></li><li><p>为了实现复杂的网络功能，采用分层方式设计、实现和调试 </p><ul><li>应用层，传输层，网络层，数据链路层，物理层 </li><li>协议数据单位： <ul><li>报文，报文段，分组，帧，位</li></ul></li></ul></li><li><p>从 服务角度看互联网 </p><ul><li>通信服务基础设施 <ul><li>提供的通信服务：面向连接 无连接</li></ul></li><li>应用</li></ul></li><li><p>应用之间的交互 </p><ul><li>C&#x2F;S模式 </li><li>P2P模式</li></ul></li><li><p>数据交换 </p><ul><li>分组数据交换 </li><li>线路交换 </li><li>比较 线路交换和分组交换</li></ul></li><li><p>分组交换的2种方式 </p><ul><li>虚电路 </li><li>数据报</li></ul></li><li><p>接入网和物理媒介 </p><ul><li>接入网技术： <ul><li>住宅：ADSL，拨号，cable modem </li><li>单位：以太网 </li><li>无线接入方式</li></ul></li><li>物理媒介 <ul><li>光纤，同轴电缆，以太网，双绞线</li></ul></li></ul></li><li><p>ISP层次结构</p></li><li><p>分组交换网络中延迟和丢失是如何发生的 </p><ul><li>延迟的组成：处理、传输、传播、排队</li></ul></li><li><p>网络的分层体系结构 </p><ul><li>分层体系结构 </li><li>服务 </li><li>协议数据单元 </li><li>封装与解封装</li></ul></li><li><p>历史</p></li></ul><hr><p>对应视频</p><ul><li><a href="https://www.bilibili.com/video/BV1JV411t7ow?p=3&vd_source=49e30194f6d5798a1f90d69dad9c0460">1.1 什么是Internet？_哔哩哔哩_bilibili</a></li><li>…</li><li><a href="https://www.bilibili.com/video/BV1JV411t7ow?p=11&vd_source=49e30194f6d5798a1f90d69dad9c0460">1.9 小结_哔哩哔哩_bilibili</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计网概述 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo文章插入本地图片</title>
      <link href="/2023/08/12/hexo%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/"/>
      <url>/2023/08/12/hexo%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
      
        <content type="html"><![CDATA[<h2 id="方法一：安装插件"><a href="#方法一：安装插件" class="headerlink" title="方法一：安装插件"></a>方法一：安装插件</h2><ol><li>在<code>Typora文件</code> –&gt; <code>设置偏好</code> –&gt; <code>图像</code>。在<code>插入图片时</code>选择复制到指定路径&#96;，设置为</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./$&#123;filename&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>安装插件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-asset-img --save</span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件（可以不配置，Typora复制图片时就会创建目录）<ul><li>在 Hexo 根目录打开配置文件 <code>_config.yml</code></li><li>搜索 <code>post_asset_folder</code>，<code>false</code> 改为 <code>true</code></li><li><code>hexo new page</code> 生成新文章，会在同级目录创建一个同名文件夹。</li></ul></li></ol><blockquote><p>大概是从 <code>Hexo 5</code> 开始<a href="https://github.com/xcodebuild/hexo-asset-image">hexo-asset-image</a> 已无效。</p></blockquote><hr><h2 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h2><p>官方提供的方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure><p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p><blockquote><p>但是这样不方便，Typora不能显示图片。</p></blockquote><hr><h2 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h2><p><a href="https://github.com/hexojs/hexo-renderer-marked">hexo-renderer-marked</a> 3.1.0 引入了一个新的选项，其允许你无需使用 <code>asset_img</code> 标签插件就可以在 markdown 中嵌入图片</p><p>如需启用：修改一下配置文件_config.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">marked:</span></span><br><span class="line">  <span class="attr">prependRoot:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">postAsset:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>然后再配置一下Typora</p><ol><li><p>在Hexo根目录（<code>HexoBlog</code>）的<code>source</code>下新建<code>imags</code>文件夹。</p><blockquote><p>注意<code>imags</code>与<code>_posts</code><strong>同级</strong>。</p></blockquote><p><img src="/../images/hexo%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/image-20230813232133245.png" class="lazyload placeholder" data-srcset="/../images/hexo%E6%8F%92%E5%85%A5%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/image-20230813232133245.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230813232133245"></p></li><li><p>在Typora<code>文件</code> –&gt; <code>设置偏好</code> –&gt; <code>图像</code>。在<code>插入图片时</code>选择<code>复制到指定路径</code>，设置为</p></li></ol><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">../../source/images//$&#123;filename&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在<code>格式</code> –&gt; <code>图像</code> –&gt; <code>设置图片根目录</code>将<code>HexoBlog/source</code>设置为<strong>根目录</strong>。（本人测试不设置根目录也行，根据自己情况来设置）</li></ol><hr><p>参考文章</p><ul><li><p><a href="https://moeci.com/posts/hexo-typora/">Hexo + Typora + 开发Hexo插件 解决图片路径不一致 | yiyun’s Blog (moeci.com)</a></p></li><li><p><a href="https://www.zhihu.com/question/419663130">(1 条消息) hexo文章中如何放入图片? - 知乎 (zhihu.com)</a></p></li><li><p><a href="https://hexo.io/zh-cn/docs/asset-folders">资源文件夹 | Hexo</a></p></li><li><p><a href="https://link.zhihu.com/?target=https://yinyoupoet.github.io/2019/09/03/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87/">typora + hexo博客中插入图片</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> hexo配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo本地图片 </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022 CSP-J1题目</title>
      <link href="/2023/08/11/2022%E5%B9%B4CSP-J1/"/>
      <url>/2023/08/11/2022%E5%B9%B4CSP-J1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、单项选择题"><a href="#一、单项选择题" class="headerlink" title="一、单项选择题"></a>一、单项选择题</h1><p>第1题</p><p>以下哪种功能没有涉及C++语言的面向对象特性支持：（ ）。</p><p>A. C++ 中调用 <code>printf</code> 函数</p><p>B. C++ 中调用用户定义的类成员函数</p><p>C. C++ 中构造一个 <code>class</code> 或 <code>struct</code></p><p>D. C++ 中构造来源于同一基类的多个派生类</p><blockquote><p>选A。其他三个选项都有<strong>类</strong>。</p></blockquote><p>第 2 题</p><p>有 6 个元素，按照 6、5、4、3、2、1 的顺序进入栈 S，请问下列哪个出栈序列是非法的（ ）。</p><p>A. 5 4 3 6 1 2</p><p>B. 4 5 3 1 2 6</p><p>C. 3 4 6 5 2 1</p><p>D. 2 3 4 1 5 6</p><blockquote><p>选C。</p></blockquote><div class="mermaid">graph LR     A(&quot;3456&quot;) --&gt;|弹出3| B(&quot;456&quot;) --&gt;|弹出4| C(&quot;56&quot;) --&gt;|弹出6| D[6出不来]style D fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">      A(&quot;3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6&quot;) --&gt;|弹出3| B(&quot;4</span><br><span class="line">5</span><br><span class="line">6&quot;) --&gt;|弹出4| C(&quot;5</span><br><span class="line">6&quot;) --&gt;|弹出6| D[6出不来]</span><br><span class="line"></span><br><span class="line"> style D fill:#bbf,stroke:#f66,stroke-width:2px,color:#fff,stroke-dasharray: 5 5</span><br></pre></td></tr></table></figure><p>第 3 题</p><p>运行以下代码片段的行为是（ ）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">101</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">201</span>;</span><br><span class="line"><span class="type">int</span> *p = &amp;x;</span><br><span class="line"><span class="type">int</span> *q = &amp;y;</span><br><span class="line">p = q;</span><br></pre></td></tr></table></figure><p>A. 将 x 的值赋为 201</p><p>B. 将 y 的值赋为 101</p><p>C. 将 q 指向 x 的地址</p><p>D. 将 p 指向 y 的地址</p><blockquote><p>选D。</p></blockquote><p>第 4 题</p><p>链表和数组的区别包括（ ）。</p><p>A. 数组不能排序，链表可以</p><p>B. 链表比数组能存储更多的信息</p><p>C. 数组大小固定，链表大小可动态调整</p><p>D. 以上均正确</p><blockquote><p>选C。A错误，数组可以排序。B错误，没有上下文，不能确定。</p></blockquote><p>第 5 题</p><p>对假设栈 S 和队列 Q 的初始状态为空。存在 e1~e6 六个互不相同的数据，每个数据按照进栈 S、出栈 S、进队列 Q、出队列 Q 的顺序操作，不同数据间的操作可能会交错。已知栈 S 中依次有数据 e1、e2、e3、e4、e5 和 e6 进栈，队列 Q 依次有数据 e2、e4、e3、e6、e5和 e1 出队列。则栈 S 的容量至少是（ ）个数据。</p><p>A. 2</p><p>B. 3</p><p>C. 4</p><p>D. 6</p><blockquote><p>选B。<strong>出队列</strong>的顺序跟<strong>进队列</strong>的顺序一样，跟第2题差不多，出队列Q的顺序看作<strong>出栈S</strong>的顺序即可。<br>栈容量最多为3。</p></blockquote><div class="mermaid">graph LR      A(&quot;e2e1&quot;) --&gt;|弹出e2| B(&quot;e4e3e1&quot;) --&gt;|弹出e4| C(&quot;e3e1&quot;) --&gt;|弹出e3, e5 e6进栈| D(&quot;e6e5e1&quot;) --&gt;|依次弹出e6 e5 e1| empty</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">      A(&quot;e2</span><br><span class="line">e1&quot;) --&gt;|弹出e2| B(&quot;e4</span><br><span class="line">e3</span><br><span class="line">e1&quot;) --&gt;|弹出e4| C(&quot;e3</span><br><span class="line">e1&quot;) --&gt;|弹出e3, e5 e6进栈| D(&quot;e6</span><br><span class="line">e5</span><br><span class="line">e1&quot;) --&gt;|依次弹出e6 e5 e1| empty</span><br></pre></td></tr></table></figure><p>第 6 题</p><p>对表达式 <code>a+(b-c)*d</code> 的前缀表达式为（ ），其中 +、-、* 是运算符。</p><p>A. <code>*+a-bcd</code></p><p>B. <code>+a*-bcd</code></p><p>C. <code>abc-d*+</code></p><p>D. <code>abc-+d</code></p><blockquote><p>选B。</p><p>方法1：按照运算顺序，把运算符放前面。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">第一个算 b - c</span><br><span class="line">把 - 放前面，变成 - b c</span><br><span class="line"></span><br><span class="line">然后乘d，(- b c) * d</span><br><span class="line">* 放前面，变成 * (- b c) d</span><br><span class="line"></span><br><span class="line">最后加a，a + * (- b c) d</span><br><span class="line">+ 放前面，变成 + a * (- b c) d</span><br></pre></td></tr></table></figure><blockquote><p>方法二：根据表达式画一个二叉树，然后先序遍历。<br>得到<code>+ a * - b c d</code></p></blockquote><div class="mermaid">flowchart TB+ --&gt; a &amp; ** --&gt; - &amp; d- --&gt; b &amp; c</div><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">+ --&gt; a &amp; *</span><br><span class="line">* --&gt; - &amp; d</span><br><span class="line">- --&gt; b &amp; c</span><br></pre></td></tr></table></figure><p>第 7 题</p><p>假设字母表 ｛a,b,c,d,e｝ 在字符串出现的频率分别为 10%，15%，30%，16%，29%。若使用哈夫曼编码方式对字母进行不定长的二进制编码，字母 d 的编码长度（ ）位。</p><p>A. 1</p><p>B. 2</p><p> C. 2 或 3</p><p>D. 3</p><blockquote><p>选B。构造哈夫曼树，每次选最小的两个数，合成一个新节点。</p><p><img src="/../images/2022%E5%B9%B4CSP-J1/image-20230819120436295.png" class="lazyload placeholder" data-srcset="/../images/2022%E5%B9%B4CSP-J1/image-20230819120436295.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819120436295"></p><p>到达d节点的路径为0 0，长度为2。</p></blockquote><p>第 8 题</p><p>一棵有 n 个结点的完全二叉树用数组进行存储与表示，已知根结点存储在数组的第 1 个位置。若存储在数组第 9 个位置的结点存在兄弟结点和两个子结点，则它的兄弟结点和右子结点的位置分别是（ ）。</p><p>A. 8、18</p><p>B. 10、18</p><p>C. 8、19</p><p>D. 10、19</p><blockquote><p>选C。</p><ul><li>9是奇数，是右子节点，兄弟节点在左边。</li><li>左子<code>2 * x</code>，右子<code>2 * x + 1</code>，9的右子节点位置为<code>2 * 9 + 1 = 19</code>。</li></ul></blockquote><p>第 9 题</p><p>考虑由 N 个顶点构成的有向连通图，采用邻接矩阵的数据结构表示时，该矩阵中至少存在（ ）个非零元素。</p><p>A. N − 1</p><p>B. N</p><p>C. <em>N</em>+1</p><p>D. $N^2$</p><blockquote><p>选B。边最少的情况，就是每个顶点只有一条入边和一条出边，连成一个圈，即连通图。</p></blockquote><p>第 10 题</p><p>以下对数据结构的表述不恰当的一项为：（ ）。</p><p>A. 图的深度优先遍历算法常使用的数据结构为栈。</p><p>B. 栈的访问原则后进先出，队列的访问原则是先进先出。</p><p>C. 队列常常被用于广度优先搜索算法。</p><p>D. 栈与队列存在本质不同，无法用栈实现队列。</p><blockquote><p>选D。虽然本质不同，但是勉强能用，比较麻烦，用两个栈就能实现。</p><ul><li>入第1个栈，变成倒序。</li><li>入第2个栈，倒序反过来，就变回原来的顺序。</li></ul></blockquote><p>第 11 题</p><p>以下哪组操作能完成在双向循环链表结点 p 之后插入结点 s 的效果（其中，next 域为结点的直接后继，prev 域为结点的直接前驱）：（ ）。</p><p>A. <code>p-&gt;next-&gt;prev=s; s-&gt;prev=p; p-&gt;next=s; s-&gt;next=p-&gt;next;</code></p><p>B. <code>P-&gt;next-&gt;prev=s; p-&gt;next=s; s-&gt;prev=p; s-&gt;next=p-&gt;next;</code></p><p>C. <code>s-&gt;prev=p; s-&gt;next=p-&gt;next; P-&gt;next=s; p-&gt;next-&gt;prev=s;</code></p><p>D. <code>s-&gt;next=p-&gt;next; p-&gt;next-&gt;prev=s; s-&gt;prev=p; p-&gt;next=s;</code></p><blockquote><p>选D。</p><ul><li><code>s-&gt;next = p-&gt;next;</code>在<code>p-&gt;next = s;</code> 前，否则就变成<code>s-&gt;next = s</code></li><li><code>p-&gt;next-&gt;prev = s;</code>在<code>p-&gt;next = s;</code>前，否则变成<code>s-&gt;prev = s</code></li></ul></blockquote><p>第 12 题</p><p>以下排序算法的常见实现中，哪个选项的说法是错误的：（ ）。</p><p>A. 冒泡排序算法是稳定的</p><p>B. 简单选择排序是稳定的</p><p>C. 简单插入排序是稳定的</p><p>D. 归并排序算法是稳定的</p><blockquote><p>选B。<br><img src="/../images/2022%E5%B9%B4CSP-J1/image-20230819120918006.png" class="lazyload placeholder" data-srcset="/../images/2022%E5%B9%B4CSP-J1/image-20230819120918006.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819120918006"></p></blockquote><ul><li>稳定排序：<ul><li>插入排序，基数排序，归并排序，冒泡排序，计数排序。</li></ul></li><li>不稳定排序：<ul><li>快速排序，希尔排序，简单选择排序，堆排序</li></ul></li></ul><p>第 13 题</p><p>八进制数 32.1 对应的十进制数是（ ）。</p><p>A. 24.125</p><p>B. 24.250</p><p>C. 26.125</p><p>D. 26.250</p><blockquote><p>选C。$3<em>8^1 + 3</em>8^0 + 1*8^{-1} &#x3D; 26.125$</p></blockquote><p>第 14 题</p><p>一个字符串中任意个连续的字符组成的子序列称为该字符串的子串，则字符串 abcab 有（ ）个内容互不相同的子串。</p><p>A. 12</p><p>B. 13</p><p>C. 14</p><p>D. 15</p><blockquote><p>选B。注意是<strong>子串</strong>，得连续，不是子序列。</p><ul><li>长度0：空串</li><li>长度1:   a、b、c</li><li>长度2：ab、bc、ca</li><li>长度3：abc、bca、cab</li><li>长度4：abca、bcab</li><li>长度5：abcab</li></ul></blockquote><p>第 15 题</p><p>以下对递归方法的描述中，正确的是：（ ）。</p><p>A. 递归是允许使用多组参数调用函数的编程技术</p><p>B. 递归是通过调用自身来求解问题的编程技术</p><p>C. 递归是面向对象和数据而不是功能和逻辑的编程语言模型</p><p>D. 递归是将用某种高级语言转换为机器代码的编程技术</p><blockquote><p>选B。</p></blockquote><hr><h1 id="二、阅读程序"><a href="#二、阅读程序" class="headerlink" title="二、阅读程序"></a>二、阅读程序</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std；</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> x, y；</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; y；</span><br><span class="line">    x = (x | x &lt;&lt; <span class="number">2</span>)&amp; <span class="number">0x33</span>；</span><br><span class="line">    x = (x | x &lt;&lt; <span class="number">1</span>)&amp; <span class="number">0x55</span>；</span><br><span class="line">    y = (y | y &lt;&lt; <span class="number">2</span>)&amp; <span class="number">0x33</span>；</span><br><span class="line">    y = (y | y &lt;&lt; <span class="number">1</span>)&amp; <span class="number">0x55</span>；</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> z = x | y &lt;&lt; <span class="number">1</span>；</span><br><span class="line">    cout &lt;&lt; z &lt;&lt; endl；</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>假设输入的 x、y 均是不超过 15 的自然数，完成下面的判断题和单选题：</strong></p><p><strong>判断题</strong></p><p>1）删去第 7 行与第 13 行的 unsigned，程序行为不变。（√）</p><p>2）将第 7 行与第 13 行的 short 均改为 char，程序行为不变。（×）</p><p>3）程序总是输出一个整数“0”。（×）</p><p>4）当输入为“2 2”时，输出为“10”。（×）</p><p>5）当输入为“2 2”时，输出为“59”。（×）</p><p><strong>单选题</strong></p><p>6）当输入为“13 8” 时，输出为（ ）。</p><p>A. “0”</p><p>B. “209”</p><p>C. “197”</p><p>D. “226”</p><blockquote><p>选B。</p></blockquote><p><img src="/../images/2022%E5%B9%B4CSP-J1/image-20230819121455261.png" class="lazyload placeholder" data-srcset="/../images/2022%E5%B9%B4CSP-J1/image-20230819121455261.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819121455261"></p><h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;limits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">105</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> h[MAXN][MAXK];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ret = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        ret = <span class="built_in">min</span>(ret, <span class="built_in">max</span>(<span class="built_in">f</span>(n - i,m), <span class="built_in">f</span>(i - <span class="number">1</span>, m - <span class="number">1</span>)) + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">g</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n; i++)</span><br><span class="line">        h[i][<span class="number">1</span>]= i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>;j&lt;= m; j++)</span><br><span class="line">        h[<span class="number">0</span>][j]= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i= <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j= <span class="number">2</span>; j &lt;= m; j++)&#123;</span><br><span class="line">            h[i][j] = numeric_limits&lt;<span class="type">int</span>&gt;::<span class="built_in">max</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>;k &lt;= i;k++)</span><br><span class="line">                h[i][j]= <span class="built_in">min</span>(</span><br><span class="line">                h[i][j],</span><br><span class="line">                <span class="built_in">max</span>(h[i - k][j],h[k - <span class="number">1</span>][j - <span class="number">1</span>]) +<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> h[n][m];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m;</span><br><span class="line">    cin &gt;&gt; n&gt;&gt; m;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">f</span>(n, m) &lt;&lt; endl &lt;&lt; <span class="built_in">g</span>(n, m)&lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>假设输入的n、m均是不超过100 的正整数，完成下面的判断题和单选题：</strong></p><p><strong>判断题</strong></p><p>1）当输入为“7 3”时，第 19 行用来取最小值的 min 函数执行了 449 次。（ × ）</p><p>2）输出的两行整数总是相同的。（ √ ）</p><p>3）当 m 为 1 时，输出的第一行总为 n。（ √ ）</p><p><strong>单选题</strong></p><p>4）算法 <em>g</em>(<em>n</em>,<em>m</em>) 最为准确的时间复杂度分析结果为（ ）。</p><p>A. <em>O</em>($n^{3&#x2F;2}m$)</p><p>B. <em>O</em>(<em>nm</em>)</p><p>C. <em>O</em>($n^2m$)</p><p>D. <em>O</em>($nm^2$)</p><blockquote><p>选C。</p></blockquote><p>5）当输入为“20 2”时，输出的第一行为（ ）。</p><p>A. “4”</p><p>B. “5”</p><p>C. “6” </p><p>D. “20”</p><blockquote><p>选C。</p></blockquote><p>6）当输入力“100 100”时，输出的第一行为（ ）。</p><p>A. “6”</p><p>B. “7”</p><p>C. “8”</p><p>D. “9”</p><blockquote><p>选B。</p></blockquote><h2 id="2-3"><a href="#2-3" class="headerlink" title="2.3"></a>2.3</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n,k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (mid * mid &lt;= n) l = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solve2</span><span class="params">(<span class="type">double</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">        x = (x + n / x) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="type">double</span> ans = <span class="built_in">solve2</span>(<span class="built_in">solve1</span>());</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; <span class="string">&#x27; &#x27;</span> &lt;&lt; (ans * ans == n) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>假设 int 为32位有符号整数类型，输入的 n 是不超过47000的自然数、k 是不超过 int 表示范围的自然数，完成下面的判断题和单选题：</strong></p><blockquote><p><code>solve1</code>函数用二分答案，找到小于等于根号n的最大整数。<br><code>solve2</code>函数中用到了牛顿迭代法求根号。<a href="https://www.zhihu.com/question/20690553">如何通俗易懂地讲解牛顿迭代法求开方（数值分析）？ - 知乎</a></p></blockquote><p><strong>判断题</strong></p><p>1）该算法最准确的时间复杂度分析结果为 O(logn+k)。（ √ ）</p><blockquote><p>正确，<code>solve1</code>二分法，时间复杂度为logn，<code>solve2</code>循环k次，时间复杂度为k，总的时间复杂度就为logn + k。</p></blockquote><p>2）当输入为“9801 1”时，输出的第一个数为“99”。（ √ ）</p><blockquote><p>正确，99的平方就是9081。</p></blockquote><p>3）对于任意输入的 n，随着所输入 k 的增大，输出的第二个数会变成“1”。（ × ）</p><blockquote><p>错误。double类型有误差。</p></blockquote><p>4）该程序有存在缺陷。当输入的 n 过大时，第 12 行的乘法有可能溢出，因此应当将 mid 强制转换为 64 位整数再计算。（ × ）</p><blockquote><p>错误，n不超过47000，mid最大<code>47000 / 2 = 23500</code>，int类型最大值为2147483647，开根号46341，比mid最大值大。</p></blockquote><p><strong>单选题</strong></p><p>5）当输入为“2 1”时，输出的第一个数最接近（ ）。</p><p>A. 1</p><p>B. 1.414</p><p>C. 1.5</p><p>D. 2</p><blockquote><p>选C。<code>solve1</code>返回1，<code>solve2</code>返回<code>(1 + 2 / 1) / 2 = 1.5</code></p></blockquote><p>6）当输入为“3 10”时，输出的第一个数最接近（ ）。</p><p> A. 1.7</p><p>B. 1.732</p><p>C. 1.75</p><p>D. 2</p><blockquote><p>选B。1.732，次数越多，越接近根号3。</p></blockquote><p>7）当输入为 “256 11” 时，输出的第一个数（ ）。</p><p>A. 等于 16</p><p>B. 接近但小于 16</p><p>C. 接近但大于 16</p><p>D. 前三种情况都有可能</p><blockquote><p>选A。16的平方为256，solve1二分能找出来。</p></blockquote><hr><h1 id="三、完善程序"><a href="#三、完善程序" class="headerlink" title="三、完善程序"></a>三、完善程序</h1><h2 id="3-1-枚举因数"><a href="#3-1-枚举因数" class="headerlink" title="3.1 枚举因数"></a>3.1 枚举因数</h2><p>从小到大打印正整数 n 的所有正因数。</p><p>试补全枚举程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; fac;</span><br><span class="line">    fac.<span class="built_in">reserve</span>((<span class="type">int</span>)<span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(n)));</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i * i &lt; n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (①)&#123;</span><br><span class="line">            fac.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; fac.<span class="built_in">size</span>(); ++k)&#123;</span><br><span class="line">        cout &lt;&lt; ② &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (③) &#123;</span><br><span class="line">        cout &lt;&lt; ④ &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = fac.<span class="built_in">size</span>() - <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k)&#123;</span><br><span class="line">        cout &lt;&lt; ⑤ &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/../images/2022%E5%B9%B4CSP-J1/image-20230819122914881.png" class="lazyload placeholder" data-srcset="/../images/2022%E5%B9%B4CSP-J1/image-20230819122914881.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819122914881"></p><blockquote><ol><li>A。判断i是否因数。</li><li>B。下标访问。</li><li>C。循环中运行了 1 到 根号n - 1 的数，此时 i 为根号n，没有判断是否因数，需要判断一下。</li><li>D。打印i。</li><li>A。打印大于根号n的数，用 n 除以 前面得到的因数 得到结果。</li></ol></blockquote><hr><h2 id="3-2-洪水填充"><a href="#3-2-洪水填充" class="headerlink" title="3.2 洪水填充"></a>3.2 洪水填充</h2><p>现有用字符标记像素颜色的 8x8 图像。颜色填充的操作描述如下：给定起始像素的位置待填充的颜色，将起始像素和所有可达的像素（可达的定义：经过一次或多次的向上、下、左、右四个方向移动所能到达且终点和路径上所有像素的颜色都与起始像素颜色相同），替换为给定的颜色。<br>试补全程序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ROWS = <span class="number">8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> COLS = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> r, c;</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">int</span> r, <span class="type">int</span> c): <span class="built_in">r</span>(r), <span class="built_in">c</span>(c) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_valid</span><span class="params">(<span class="type">char</span> image[ROWS][COLS], Point pt,</span></span></span><br><span class="line"><span class="params"><span class="function">              <span class="type">int</span> prev_color, <span class="type">int</span> new_color)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> r = pt.r;</span><br><span class="line">    <span class="type">int</span> c = pt.c;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> &lt;= r &amp;&amp; r &lt; ROWS &amp;&amp; <span class="number">0</span> &lt;= c &amp;&amp; c &lt; COLS &amp;&amp;</span><br><span class="line">            ① &amp;&amp; image[r][c] != new_color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">flood_fill</span><span class="params">(<span class="type">char</span> image[ROWS][COLS], Point cur, <span class="type">int</span> new_color)</span> </span>&#123;</span><br><span class="line">    queue&lt;Point&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(cur);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> prev_color = image[cur.r][cur.c];</span><br><span class="line">    ②;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        Point pt = queue.<span class="built_in">front</span> ();</span><br><span class="line">        queue.<span class="built_in">pop</span> ();</span><br><span class="line"></span><br><span class="line">        Point points[<span class="number">4</span>] = &#123;③, <span class="built_in">Point</span>(pt.r - <span class="number">1</span>, pt.c),</span><br><span class="line">                           <span class="built_in">Point</span>(pt.r, pt.c + <span class="number">1</span>), <span class="built_in">Point</span>(pt.r, pt.c - <span class="number">1</span>)&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p ; points) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">is_valid</span>(image, p, prev_color, new_color)) &#123;</span><br><span class="line">                ④;</span><br><span class="line">                ⑤;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> image[ROWS][COLS] = &#123;&#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;r&#x27;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;,</span><br><span class="line">                              &#123;<span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">Point <span class="title">cur</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">    <span class="type">char</span> new_color = <span class="string">&#x27;y&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">flood_fill</span>(image, cur, new_color);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> r = -; r &lt; ROWS; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> c = <span class="number">0</span>; c &lt; COLS; c++) &#123;</span><br><span class="line">            cout &lt;&lt; image[r][c] &lt;&lt; <span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">        cout &lt;&lt; endl;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">//输出:</span></span><br><span class="line"><span class="string">// g g g g g g g g</span></span><br><span class="line"><span class="string">// g g g g g g r r</span></span><br><span class="line"><span class="string">// g r r g g r g g</span></span><br><span class="line"><span class="string">// g y y y y r g r</span></span><br><span class="line"><span class="string">// g g g y y r g r</span></span><br><span class="line"><span class="string">// g g g y y y y r</span></span><br><span class="line"><span class="string">// g g g g g y g g</span></span><br><span class="line"><span class="string">// g g g g g y y g</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    return 0;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="/../images/2022%E5%B9%B4CSP-J1/image-20230819123011193.png" class="lazyload placeholder" data-srcset="/../images/2022%E5%B9%B4CSP-J1/image-20230819123011193.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230819123011193"></p><blockquote><ol><li>A。与新颜色一样已经有了，还要与<strong>起点的颜色</strong>相同。</li><li>B。存完了旧颜色，起点换成新颜色。</li><li>C。方向上下左右，还差方向下。</li><li>D。新位置更新为新颜色。</li><li>A。新位置入队列。</li></ol></blockquote><hr><p>参考文章及视频</p><ul><li><a href="https://www.bilibili.com/video/BV1WV4y1K7dd/?spm_id_from=333.337.search-card.all.click&vd_source=49e30194f6d5798a1f90d69dad9c0460">2022年CSP-J入门级初赛（第一轮）真题讲解_哔哩哔哩_bilibili</a></li><li><a href="https://ti.luogu.com.cn/problemset/1039">试题 - CSP 2022 入门级第一轮洛谷有题</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> CSP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 2022CSP-J1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>17 动态规划入门</title>
      <link href="/2023/08/10/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
      <url>/2023/08/10/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>灵神【基础算法精讲】视频的个人笔记。</p></blockquote><p><strong>动态规划核心</strong></p><ul><li>状态<strong>定义</strong></li><li>状态<strong>转移方程</strong></li></ul><p>启发思路（跟子集型回溯一样）</p><ul><li><strong>选和不选</strong></li><li><strong>选哪个</strong></li></ul><p><img src="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811234201400.png" class="lazyload placeholder" data-srcset="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811234201400.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230811234201400"></p><hr><h1 id="视频例题"><a href="#视频例题" class="headerlink" title="视频例题"></a>视频例题</h1><h2 id="198-打家劫舍"><a href="#198-打家劫舍" class="headerlink" title="198.打家劫舍"></a><a href="https://leetcode.cn/problems/house-robber/">198.打家劫舍</a></h2><p><img src="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811232947283.png" class="lazyload placeholder" data-srcset="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811232947283.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230811232947283"></p><p>回溯三问：</p><ol><li>当前操作？枚举<strong>第 i 个</strong>房子选或不选。</li><li>子问题？从<strong>前 i 个</strong>房子中的最高金额。</li><li>下一个子问题？<ol><li>选：从<strong>前 i-2 个</strong>房子中的最高金额。</li><li>不选：从<strong>前 i-1 个</strong>房子中的最高金额。</li></ol></li></ol><p>递归</p><ul><li>会超时</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不选和选, 前i-1和前i-2的最高金额, 取最大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>), <span class="built_in">dfs</span>(i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>记忆化搜索</p><ul><li>用数组 cache 记录 <strong>入参</strong>对应的函数<strong>返回值</strong></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cache</span><span class="params">(n, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>)  <span class="comment">//base case</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(cache[i] != <span class="number">-1</span>) <span class="keyword">return</span> cache[i];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不选和选, 前i-1和前i-2的最高金额, 取最大值</span></span><br><span class="line">            <span class="keyword">return</span> cache[i] = <span class="built_in">max</span>(<span class="built_in">dfs</span>(i - <span class="number">1</span>), <span class="built_in">dfs</span>(i - <span class="number">2</span>) + nums[i]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递推</p><ul><li>从记忆化搜索一比一翻译过来: <code>dp[i] = max(dp(i - 1), dp(i - 2) + nums[i]);</code></li><li>防止越界, dp[i]中的 i 全部+2: <code>dp[i + 2] = max(dp[i + 1], dp[i] + nums[i]);</code></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="comment">//dp[i] = max(dp(i - 1), dp(i - 2) + nums[i])</span></span><br><span class="line">            <span class="comment">//防止越界, dp[i]中的i全部+2</span></span><br><span class="line">            dp[i + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>], dp[i] + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>空间优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> f0 = <span class="number">0</span>, f1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : nums) &#123;</span><br><span class="line">            <span class="type">int</span> new_f = <span class="built_in">max</span>(f1, f0 + x);</span><br><span class="line">            f0 = f1;</span><br><span class="line">            f1 = new_f;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="课后作业"><a href="#课后作业" class="headerlink" title="课后作业"></a>课后作业</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70.爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70.爬楼梯</a></h2><p><img src="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811233037939.png" class="lazyload placeholder" data-srcset="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811233037939.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230811233037939"></p><ul><li>1 和 2 是边界，提前赋值。</li><li>楼梯有 3 阶时，有两种方法：</li><li><ul><li><strong>从 1 阶</strong> 爬 1 个台阶，到达 3 阶</li><li><strong>从 2 阶</strong> 爬 2 个台阶，到达 3 阶</li><li><strong>到达 1 阶</strong>有 1 种方法，<strong>到达 2 阶</strong>有 2 种方法，到达 3 阶楼梯有 1+2&#x3D;3 种方法。</li></ul></li><li>同理，楼梯有 i 阶</li><li><ul><li>从 i - 1 阶爬 1 个台阶</li><li>从 i - 2 阶爬 2 个台阶</li></ul></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">climbStairs</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">3</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>; dp[<span class="number">2</span>] = <span class="number">2</span>; <span class="comment">//边界</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746.使用最小花费爬楼梯"></a><a href="https://leetcode.cn/problems/min-cost-climbing-stairs/">746.使用最小花费爬楼梯</a></h2><p><img src="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811233225607.png" class="lazyload placeholder" data-srcset="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811233225607.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230811233225607"></p><p>详细题解<a href="https://leetcode.cn/problems/min-cost-climbing-stairs/solutions/177077/yi-bu-yi-bu-tui-dao-dong-tai-gui-hua-de-duo-chong-/">力扣</a></p><p>回溯三问：</p><ol><li>当前操作？枚举<strong>第 i 层</strong>从 <code>i - 1</code>层来 或 从 <code>i - 2</code>层来，然后加上<strong>第 i 层</strong>的花费。</li><li>子问题？到达<strong>第 i 层</strong>台阶的最小花费。</li><li>下一个子问题？<ol><li>到达 <code>i - 1</code>层的最小花费</li><li>到达 <code>i - 2</code>层的最小花费</li></ol></li></ol><p><strong>顶部</strong>是第 n 层，取 <code>n-1</code>和 <code>n-2</code>的最小值，<code>min(dp[n - 1], dp[n - 2])</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = cost.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line">            dp[i] = cost[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = <span class="built_in">min</span>(dp[i - <span class="number">1</span>], dp[i - <span class="number">2</span>]) + cost[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(dp[n - <span class="number">1</span>], dp[n - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="2466-统计构造好字符串的方案数"><a href="#2466-统计构造好字符串的方案数" class="headerlink" title="2466.统计构造好字符串的方案数"></a><a href="https://leetcode.cn/problems/count-ways-to-build-good-strings/">2466.统计构造好字符串的方案数</a></h2><p><img src="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811233313270.png" class="lazyload placeholder" data-srcset="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811233313270.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230811233313270"></p><p>记忆化搜索</p><ul><li><code>dfs</code>得出长度为 i 的好字符串的方案数</li><li>循环, 求出长度从 <code>low</code>到 <code>high</code>的总方案数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cache</span><span class="params">(high + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>)&gt; dfs = [&amp;] (<span class="type">int</span> i) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cache[i] != <span class="number">-1</span>) <span class="keyword">return</span> cache[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> cache[i] = (<span class="built_in">dfs</span>(i - zero) + <span class="built_in">dfs</span>(i - one)) % MOD;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; ++i) &#123;</span><br><span class="line">            ans += <span class="built_in">dfs</span>(i) % MOD;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>递推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countGoodStrings</span><span class="params">(<span class="type">int</span> low, <span class="type">int</span> high, <span class="type">int</span> zero, <span class="type">int</span> one)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(high + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= high; ++i) &#123;</span><br><span class="line">            <span class="comment">//dp[i] = dp[i - zero] + dp[i - one]; 会越界</span></span><br><span class="line">            <span class="keyword">if</span>(i &gt;= zero) dp[i] += dp[i - zero];</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= one) dp[i] += dp[i - one];</span><br><span class="line">            dp[i] %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = low; i &lt;= high; ++i) &#123; <span class="comment">//字符串长度为i的方案数</span></span><br><span class="line">            ans += dp[i] % MOD;</span><br><span class="line">            ans %= MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><hr><h2 id="213-打家劫舍-II"><a href="#213-打家劫舍-II" class="headerlink" title="213.打家劫舍 II"></a><a href="https://leetcode.cn/problems/house-robber-ii/">213.打家劫舍 II</a></h2><p><img src="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811233333712.png" class="lazyload placeholder" data-srcset="/../images/17-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/image-20230811233333712.png" srcset="https://pic1.zhimg.com/v2-cd38920285d125be80b3eb504052c550_b.webp" alt="image-20230811233333712"></p><p>官方题解<a href="https://leetcode.cn/problems/house-robber-ii/solutions/722767/da-jia-jie-she-ii-by-leetcode-solution-bwja/">力扣</a></p><p>跟例题打家劫舍的区别</p><ul><li><strong>第一间</strong>房子和<strong>最后一间</strong>房子不能同时偷</li></ul><p>用打家劫舍的解法，算两次</p><ul><li>第一次求 <code>0 ~ n-2</code></li><li>第二次求 <code>1 ~ n-1</code></li><li>最后求最大值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        function&lt;<span class="type">int</span>(<span class="type">int</span>, <span class="type">int</span>)&gt; dpRange = [&amp;] (<span class="type">int</span> start, <span class="type">int</span> end) -&gt; <span class="type">int</span> &#123;</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; <span class="built_in">dp</span>(n + <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; ++i) &#123;</span><br><span class="line">                dp[i + <span class="number">2</span>] = <span class="built_in">max</span>(dp[i + <span class="number">1</span>], dp[i] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> dp[end + <span class="number">2</span>];</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//0 ~ n-2 和 1 ~ n-1 的最大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">dpRange</span>(<span class="number">0</span>, n - <span class="number">2</span>), <span class="built_in">dpRange</span>(<span class="number">1</span>, n - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/10/hello-world/"/>
      <url>/2023/08/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
